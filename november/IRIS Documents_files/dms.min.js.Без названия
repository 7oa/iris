'use strict';

(function () {
    angular.module('irisApp').service('DmsActions', ["$translate", "$uibModal", "$q", "$rootScope", "$compile", "FoldersService", "FilesService", function ($translate, $uibModal, $q, $rootScope, $compile, FoldersService, FilesService) {
        function openSelectFolderModal(_folder, forFiles) {
            return $uibModal.open({
                templateUrl: iris.config.moduleUrl + '/templates/dms.files.move.html',
                controller: 'DmsFileMoveCtrl',
                size: 'sm',
                resolve: {
                    'folder': function folder() {
                        return _folder;
                    },
                    'enable_root': function enable_root() {
                        return forFiles ? false : _folder.parentId != null;
                    },
                    'is_folder_moved': function is_folder_moved() {
                        return !forFiles;
                    },
                    'action_label': function action_label() {
                        return 'label.Move';
                    }
                }
            }).result;
        }

        function moveFolderCore(params, targetFolder, isUndo) {
            iris.loader.start();
            return FoldersService.moveToFolder(params.folder.id, targetFolder.id).then(function () {
                !isUndo && sendUndoAlert('Folder \'' + params.folder.name + '\' was moved to folder \'' + (targetFolder.name || $translate.instant("label.Root")) + '\'');
                params.onAfterAction && params.onAfterAction();
                iris.loader.stop();
            }, function () {
                params.onAfterAction && params.onAfterAction();
                iris.loader.stop();
            });
        }

        function moveFilesCore(params, targetFolder, isUndo) {
            iris.loader.start();
            var promises = params.fileIds.map(function (fileId) {
                return FilesService.moveToFolder(fileId, targetFolder.id);
            });
            return $q.all(promises).then(function () {
                !isUndo && sendUndoAlert('Documents were moved to folder \'' + targetFolder.name + '\'');
                params.onAfterAction && params.onAfterAction();
                iris.loader.stop();
            }, function () {
                params.onAfterAction && params.onAfterAction();
                iris.loader.stop();
            });
        }

        function removeFileCore(params) {
            return FilesService.remove(params.file.id, params.isForce).then(function () {
                FoldersService.getById(params.file.parentId).$promise.then(function (res) {
                    if (!res.isTrashBin) {
                        sendUndoAlert('Document \'' + params.file.name + '\' was moved to recycle bin');
                    } else {
                        alertify.success($translate.instant('text.RemoveItemSuccess'));
                    }
                });
                params.onAfterAction && params.onAfterAction();
            }, function () {
                params.onAfterAction && params.onAfterAction();
            });
        }

        function removeFilesCore(params) {
            iris.loader.start();

            var promises = params.files.filter(function (f) {
                return f.selected;
            }).map(function (f) {
                return FilesService.remove(f.id);
            });
            return $q.all(promises).then(function () {
                sendUndoAlert('Documents were moved to recycle bin');
                params.onAfterAction && params.onAfterAction();
                iris.loader.stop();
            }, function () {
                params.onAfterAction && params.onAfterAction();
                iris.loader.stop();
            });
        }

        function restoreFile(params) {
            return FilesService.restore(params.file.id).then(function () {
                params.onAfterAction && params.onAfterAction();
            }, function () {
                params.onAfterAction && params.onAfterAction();
            });
        }

        function restoreFiles(params) {
            iris.loader.start();

            var promises = params.files.filter(function (f) {
                return f.selected;
            }).map(function (f) {
                return FilesService.restore(f.id);
            });
            return $q.all(promises).then(function () {
                params.onAfterAction && params.onAfterAction();
                iris.loader.stop();
            }, function () {
                params.onAfterAction && params.onAfterAction();
                iris.loader.stop();
            });
        }

        var handlers = {
            moveFolder: function moveFolder(params) {
                var defer = $q.defer();
                openSelectFolderModal(params.folder).then(function (targetFolder) {
                    targetFolder = targetFolder || { id: null };
                    moveFolderCore(params, targetFolder).then(function () {
                        defer.resolve(function () {
                            return moveFolderCore(params, { id: params.folder.parentId }, true);
                        });
                    });
                });
                return defer.promise;
            },

            moveFiles: function moveFiles(params) {
                var defer = $q.defer();
                openSelectFolderModal(params.folder, true).then(function (targetFolder) {
                    moveFilesCore(params, targetFolder).then(function () {
                        defer.resolve(function () {
                            return moveFilesCore(params, params.folder, true);
                        });
                    });
                });
                return defer.promise;
            },

            removeFile: function removeFile(params) {
                var defer = $q.defer();
                removeFileCore(params).then(function () {
                    defer.resolve(function () {
                        return restoreFile(params);
                    });
                });
                return defer.promise;
            },

            removeFiles: function removeFiles(params) {
                var defer = $q.defer();
                removeFilesCore(params).then(function () {
                    defer.resolve(function () {
                        return restoreFiles(params);
                    });
                });
                return defer.promise;
            }
        };

        var actionStack = [];

        function execute(action, params) {
            if (!handlers.hasOwnProperty(action)) return;

            handlers[action](params).then(function (uAction) {
                // TODO: use push to support not only one "undo"
                actionStack = [uAction];
            });
        }

        function undoLastAction() {
            if (!actionStack.length) return;
            actionStack[actionStack.length - 1]();
            actionStack.splice(actionStack.length - 1, 1);
        }

        function sendUndoAlert(message) {
            angular.element('body').find('.dms-actions-undo-alert-host').remove();
            var host = angular.element("<div>").addClass('dms-actions-undo-alert-host');
            host.appendTo(angular.element('body'));

            var innerScope = $rootScope.$new();
            innerScope.message = message;
            innerScope.popoverTemplate = iris.config.moduleUrl + '/templates/partial/dms-action.popover.html';
            innerScope.undo = function () {
                undoLastAction();
                angular.element('body').trigger("click");
            };

            host.html('<div uib-popover-template="popoverTemplate" popover-trigger="\'outsideClick\'" popover-animation="false" popover-placement="left" popover-class="dms-alertify-popover"></div>');
            $compile(host)(innerScope);
            host.find('div').trigger('click');
        }

        return {
            execute: execute,
            undoLastAction: undoLastAction
        };
    }]);
})();
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

angular.module('irisApp').controller('DmsCommentsPrintCtrl', ["$scope", "entity", "isFile", "comments", function ($scope, entity, isFile, comments) {
    $scope.fullPath = entity.path;
    if (isFile) $scope.fullPath += '/' + entity.name;

    $scope.comments = {
        first: [],
        second: []
    };

    fillComments();

    function fillComments() {
        var i = void 0,
            l = void 0;

        var sortedComments = [];
        comments.forEach(function (t) {
            sortedComments.push(t);
            if (t.replies && t.replies.length) {
                sortedComments.push.apply(sortedComments, _toConsumableArray(t.replies.map(function (r) {
                    r.comment = '-> ' + r.comment;
                    return r;
                })));
            }
        });

        l = sortedComments.length;
        var mid = l / 2;
        if (l % 2 > 0) {
            mid = Math.round(l / 2);
        }

        for (i = 0; i < l; i++) {
            if (i < mid) {
                $scope.comments.first.push(sortedComments[i]);
            } else {
                $scope.comments.second.push(sortedComments[i]);
            }
        }
    }
}]);
'use strict';

angular.module('irisApp').controller('DmsContactsCtrl', ["$scope", "$translate", "$uibModal", "uiGridConstants", "MailService", "ContactsService", "CompaniesService", "contacts", "companies", function ($scope, $translate, $uibModal, uiGridConstants, MailService, ContactsService, CompaniesService, contacts, companies) {
    $scope.companies = companies;
    $scope.contacts = contacts;

    $scope.gridOptions = {
        data: 'contacts',
        enableFiltering: true,
        enableGridMenu: true,
        minRowsToShow: 20,
        enableFullRowSelection: false,
        enableSelectAll: true,
        selectionRowHeaderWidth: 35,
        multiSelect: true,
        columnDefs: [{
            name: '#',
            width: 50,
            enableSorting: false,
            enableFiltering: false,
            cellTemplate: '\n                            <div class="ui-grid-cell-contents">\n                                {{rowRenderIndex + 1}} \n                            </div>'
        }, {
            field: 'userId',
            width: 30,
            displayName: '',
            enableSorting: true,
            enableFiltering: false,
            cellTemplate: '\n                            <div class="ui-grid-cell-contents">\n                                <i class="fa fa-user" \n                                   ng-if="row.entity.userId"\n                                   uib-tooltip="{{::\'label.UserHasAccount\' | translate}}"></i>\n                            </div>'
        }, {
            field: 'lastName',
            width: '*',
            displayName: $translate.instant('label.LastName'),
            enableSorting: true,
            sort: {
                direction: uiGridConstants.ASC,
                priority: 1
            }
        }, {
            field: 'firstName',
            width: '*',
            displayName: $translate.instant('label.FirstName'),
            enableSorting: true,
            sort: {
                direction: uiGridConstants.ASC,
                priority: 2
            }
        }, {
            field: 'company',
            width: '*',
            displayName: $translate.instant('label.Company'),
            enableSorting: true
        }, {
            field: 'email',
            width: '*',
            displayName: $translate.instant('label.Email'),
            enableSorting: true
        }, {
            field: 'phone',
            width: '*',
            displayName: $translate.instant('label.Phone'),
            enableSorting: true
        }, {
            name: 'actions',
            enableFiltering: false,
            displayName: $translate.instant('label.Actions'),
            width: 100,
            enableSorting: false,
            cellTemplate: '\n                            <div class="ui-grid-cell-contents actions">\n                                <button ng-if="row.entity.userId" \n                                        ng-click="grid.appScope.openUserRightsModal(row.entity)" \n                                        class="btn btn-link btn-xs" \n                                        uib-tooltip="{{::\'label.ShowUserRights\' | translate}}">\n                                    <i class="fa fa-fw fa-shield"></i>\n                                </button>\n                                <a ui-sref="contacts.edit({id:row.entity.id})" \n                                   ng-if="!row.entity.userId" \n                                   class="btn btn-link btn-xs" \n                                   uib-tooltip="{{::\'label.Edit\' | translate}}">\n                                     <i class="fa fa-fw fa-pencil"></i>\n                                </a>&nbsp;\n                                <button ng-if="!row.entity.userId" \n                                        ng-click="grid.appScope.removeContact(row.entity)" \n                                        class="btn btn-link btn-xs" \n                                        uib-tooltip="{{::\'label.dms.RemoveContact\' | translate}}">\n                                     <i class="fa fa-fw fa-trash-o"></i>\n                                 </button>\n                            </div>'
        }],
        rowTemplate: "<div ng-repeat=\"(colRenderIndex, col) in colContainer.renderedColumns track by col.colDef.name\" class=\"ui-grid-cell\" \
                    ng-class=\"{ 'ui-grid-row-header-cell': col.isRowHeader, 'row-selected':row.entity.id == grid.appScope.selected_file.id}\" ui-grid-cell ></div>",
        onRegisterApi: function onRegisterApi(gridApi) {
            $scope.gridOptions.gridAPI = gridApi;
        }
    };

    $scope.removeContact = function (contact) {
        alertify.confirm($translate.instant('text.RemoveConfirm'), function (e) {
            if (e) {
                ContactsService.removeContact(contact).then(function () {
                    alertify.success($translate.instant('text.ContactRemoved'));
                    requestContacts();
                });
            }
        });
    };

    $scope.openUserRightsModal = function (_user) {
        iris.loader.start('.app-body');

        $scope.modalInstance = $uibModal.open({
            templateUrl: iris.config.moduleUrl + '/templates/dms.contacts.rights.html',
            resolve: {
                'user': function user() {
                    return _user;
                },
                'folders': ["FoldersService", function (FoldersService) {
                    return FoldersService.requestFolders().$promise.then(function (data) {
                        return FoldersService.getAllFoldersList();
                    });
                }],
                'permissions': ["FoldersSecurityService", function (FoldersSecurityService) {
                    return FoldersSecurityService.getAllPermissions().then(function (data) {
                        return FoldersSecurityService.transformPermissions(data);
                    });
                }]
            },
            controller: 'DmsContactsRights',
            size: 'lg'
        });
    };

    $scope.openSendMessageModal = function () {
        iris.loader.start('.app-body');

        var selected_contacts = $scope.gridOptions.gridAPI.selection.getSelectedRows().map(function (u) {
            return u.email;
        });

        MailService.openSendMailModal(selected_contacts, null);
    };

    $scope.$on('updateContacts', function () {
        requestContacts();
    });

    function requestContacts() {
        ContactsService.requestContacts().then(function (requestContacts) {
            $scope.contacts = requestContacts;
        });
    }
}]);

angular.module('irisApp').controller('DmsContactsRights', ["$scope", "user", "folders", "permissions", "FoldersSecurityService", function ($scope, user, folders, permissions, FoldersSecurityService) {
    iris.loader.stop();

    $scope.user = user;
    $scope.permissions = permissions;
    $scope.folders = folders;

    $scope.hasPermission = function (subject_id, action) {
        return FoldersSecurityService.hasUGPermission(permissions, subject_id, user, action);
    };

    $scope.getFolderPath = function (folder) {
        return folder.path.substring(0, folder.path.length - folder.name.length);
    };
}]);
'use strict';

(function () {
    angular.module('irisApp').controller('DmsFileChangeWfStateCtrl', ["$scope", "$uibModalInstance", "$translate", "file", "FilesService", "workflowStates", function ($scope, $uibModalInstance, $translate, file, FilesService, workflowStates) {
        $scope.file = file;
        $scope.workflowStates = workflowStates;
        $scope.users = [];

        $scope.state = {
            fileId: file.id,
            comment: '',
            stateId: file.workflowStateId,
            notifyUsers: []
        };

        $scope.setState = function (stateId) {
            $scope.users = [];
            if (!stateId) return;

            var state = $scope.workflowStates.filter(function (s) {
                return s.id == stateId;
            })[0];
            if (!state) return;

            $scope.users = state.mergedUsers;
        };

        $scope.changeState = function () {
            $scope.state.notifyUsers = $scope.gridOptions.gridAPI ? $scope.gridOptions.gridAPI.selection.getSelectedRows() : [];
            FilesService.changeWorkflowState($scope.state).then(function () {
                alertify.success($translate.instant('label.workflows.StateChanged'));
                $uibModalInstance.close();
            });
        };

        $scope.gridOptions = {
            data: 'users',
            enablePaginationControls: false,
            paginationPageSize: 10,
            showGridFooter: true,
            enableFullRowSelection: true,
            enableSelectAll: true,
            selectionRowHeaderWidth: 35,
            multiSelect: true,
            columnDefs: [{
                field: 'id',
                width: 50,
                displayName: $translate.instant('label.Id')
            }, {
                field: 'email',
                width: '*',
                displayName: $translate.instant('label.Email')
            }, {
                field: 'profile.lastname',
                width: '**',
                displayName: $translate.instant('label.Name'),
                cellTemplate: '\n                            <div class="ui-grid-cell-contents">\n                                {{row.entity.profile.lastname}} {{row.entity.profile.firstname}}\n                            </div>'
            }, {
                field: 'profile.company.name',
                width: '*',
                displayName: $translate.instant('label.Company')
            }],
            onRegisterApi: function onRegisterApi(gridApi) {
                $scope.gridOptions.gridAPI = gridApi;
                $scope.gridOptions.gridAPI.core.on.rowsRendered($scope, function () {
                    $scope.gridOptions.gridAPI.selection.selectAllRows();
                });
            }
        };
    }]);
})();
'use strict';

(function () {
    angular.module('irisApp').controller('DmsFileEditCtrl', ["$scope", "$uibModalInstance", "$q", "$filter", "$translate", "TagsService", "file", "FilesService", "workflows", "WorkflowService", "SecurityService", "languages", "users", "dmsConfig", function ($scope, $uibModalInstance, $q, $filter, $translate, TagsService, file, FilesService, workflows, WorkflowService, SecurityService, languages, users, dmsConfig) {
        $scope.file = FilesService.createFile(file);
        $scope.file.currentWorkflowStateId = $scope.file.workflowStateId;

        var isDMSAdmin = SecurityService.hasPermissions('DMS', 'config', 'Module');

        $scope.workflows = workflows;
        $scope.languages = languages;
        $scope.users = users;
        $scope.dmsConfig = dmsConfig;
        $scope.workflowStates = [];
        $scope.file.tags = $scope.file.tags || [];
        $scope.companyTagIndex = $scope.dmsConfig.properties.findIndex(function (obj) {
            return obj.name == "Company";
        });

        $scope.file.tags.forEach(function (t) {
            var prop = $scope.dmsConfig.properties.find(function (p) {
                return !p.backField && p.name == t.type;
            });
            if (prop) prop.value = t.value;
        });
        $scope.dmsConfig.properties.filter(function (p) {
            return !!p.backField;
        }).forEach(function (p) {
            $scope.file[p.backField] && (p.value = $scope.file[p.backField]);
        });

        $scope.requestWorkflowStates = function (workflowId) {
            if (workflowId != $scope.file.workflowId) {
                $scope.file.workflowStateId = null;
                $scope.workflowStates = [];
            }
            if (!workflowId) return;

            if (file.workflowStateId && !isDMSAdmin) {
                WorkflowService.getWorkflowNextStates(workflowId, file.workflowStateId).then(function (workflowStates) {
                    return $scope.workflowStates = workflowStates;
                });
            } else {
                WorkflowService.getWorkflowStates(workflowId).then(function (workflowStates) {
                    $scope.workflowStates = workflowStates.filter(function (state) {
                        return state.type == 'START';
                    });
                    if ($scope.workflowStates.length) $scope.file.workflowStateId = $scope.workflowStates[0].id;

                    if (isDMSAdmin) {
                        $scope.workflowStates = workflowStates;
                    }
                });
            }
        };

        $scope.save = function () {
            $scope.file.workflowStateId = $scope.file.workflowStateId || $scope.file.currentWorkflowStateId;
            var promises = [];
            $scope.dmsConfig.properties.filter(function (p) {
                return !p.backField;
            }).forEach(function (p) {
                if (p.value) {
                    promises.push(TagsService.saveTag({
                        type: p.name,
                        value: p.value,
                        name: $filter('IrisFilterField')(p.value, [p.directory])
                    }));
                }
            });
            return $q.all(promises).then(function (res) {
                $scope.file.tags = res;
                $scope.dmsConfig.properties.filter(function (p) {
                    return !!p.backField;
                }).forEach(function (p) {
                    $scope.file[p.backField] = p.value;
                });
                FilesService.save($scope.file).then(function () {
                    alertify.success($translate.instant('text.dms.FileSaved'));
                    $uibModalInstance.close();
                });
            });
        };

        $scope.isStartState = function () {
            if (isDMSAdmin) return false;
            var stateId = $scope.file.currentWorkflowStateId;
            var workflowId = $scope.file.workflowId;

            if (!stateId || !workflowId) return false;

            var workflow = $scope.workflows.filter(function (wf) {
                return wf.id == workflowId;
            })[0];
            if (!workflow) return false;

            var state = workflow.workflowStates.filter(function (s) {
                return s.id == stateId;
            })[0];
            return state && state.type == 'START';
        };
    }]);
})();
'use strict';

(function () {
    angular.module('irisApp').controller('DmsFileMoveCtrl', ["$scope", "$uibModal", "$uibModalInstance", "folder", "enable_root", "is_folder_moved", "action_label", "FoldersService", function ($scope, $uibModal, $uibModalInstance, folder, enable_root, is_folder_moved, action_label, FoldersService) {
        $scope.config = iris.config;
        $scope.enable_root = enable_root || false;
        $scope.is_folder_moved = is_folder_moved;
        $scope.action_label = action_label;
        $scope.current_folder = folder;
        $scope.selected = { folder: null };
        $scope.folders = angular.copy(FoldersService.getFolders());

        $scope.setSelectedFolder = function (folder) {
            $scope.selected.folder = folder;
        };
    }]);
})();
'use strict';

(function () {
    angular.module('irisApp').controller('DmsFileShareModalCtrl', ["$scope", "$translate", "$interpolate", "$timeout", "file", "FilesService", "LinksService", function ($scope, $translate, $interpolate, $timeout, file, FilesService, LinksService) {
        $scope.linkSettings = {
            validFor: 3,
            isPermalink: false
        };

        $scope.link = null;

        $scope.targetFile = file;

        $scope.generateLink = function () {
            console.log($scope);
            FilesService.share(file, $scope.linkSettings.validFor, $scope.linkSettings.isPermalink).then(function (link) {
                $scope.showLink(LinksService.getLinkUrl(link));
            });
        };

        $scope.showLink = function (link) {
            $scope.link = link;
        };
    }]);
})();
'use strict';

(function () {
    angular.module('irisApp').controller('DmsFileToggleInProgressModalCtrl', ["$scope", "dmsAppState", "$uibModal", "$uibModalInstance", "$translate", "DmsAppService", "FilesService", function ($scope, dmsAppState, $uibModal, $uibModalInstance, $translate, DmsAppService, FilesService) {
        $scope.appBundles = [];
        $scope.appState = dmsAppState || {};
        $scope.appState.available = $scope.appState.ip && $scope.appState.active;
        $scope.appState.downloadable = $scope.appState.ip && !$scope.appState.active;

        $scope.editLocallyDescription = $translate.instant('text.dms.EditLocallyDescription');

        if (!$scope.appState.active) {
            DmsAppService.getAllBundles().then(function (bRes) {
                $scope.appBundles = bRes;
            });
        }

        $scope.getBundleDownloadUrl = function (bundle) {
            return DmsAppService.getBundleUrl(bundle.bundleName);
        };

        $scope.editLocal = function () {
            iris.loader.start('.modal-body');
            FilesService.localEdit($scope.selected_file.id, $scope.appState.ip).then(function (file) {
                iris.loader.stop('.modal-body');
                $uibModalInstance.close(false);
            });
        };

        $scope.toggleInProgress = function (isOpenUpload) {
            iris.loader.start('.modal-body');
            FilesService.toggleInProgress($scope.selected_file).then(function (file) {
                iris.loader.stop('.modal-body');
                $scope.selected_file = file;
                $scope.updateSelectedFile();
                $uibModalInstance.close(isOpenUpload);
            });
        };
    }]);
})();
'use strict';

(function () {
    angular.module('irisApp').controller('DmsFileUploadCtrl', ["$scope", "$uibModal", "$uibModalInstance", "$translate", "$window", "file", "FileUploader", "FilesService", function ($scope, $uibModal, $uibModalInstance, $translate, $window, file, FileUploader, FilesService) {
        $scope.file = file;

        $scope.uploadParams = {
            changeName: false,
            comment: ""
        };

        $scope.$watch("uploadParams", setParams, true);

        function setParams() {
            if (!$scope.uploader || !$scope.uploader.queue || !$scope.uploader.queue.length) return;

            var f = $scope.uploader.queue[0];
            f.url = FilesService.getFileContentUrl(file.id);
            if (file.ownerId) f.url += '?ownerId=' + file.ownerId;

            if ($scope.uploadParams.changeName) f.url += ($scope.file.ownerId ? "&" : "?") + 'change-name=true';
            if ($scope.uploadParams.comment) f.url += ($scope.file.ownerId || $scope.uploadParams.changeName ? "&" : "?") + ('comment=' + $window.encodeURIComponent($scope.uploadParams.comment));
        }

        $scope.uploader = new FileUploader({
            url: FilesService.getFileContentUrl(file.id),
            queueLimit: 1,
            onErrorItem: function onErrorItem() {
                alertify.error($translate.instant('text.dms.FileUploadedError'));
                $scope.hasErrors = true;
            },
            onCompleteAll: function onCompleteAll() {
                if (!$scope.hasErrors) alertify.success($translate.instant('text.dms.FileUploadedSuccess'));
                $uibModalInstance.close();
            },
            onAfterAddingFile: function onAfterAddingFile(item) {
                item.headers = {
                    'x-iris-access-token': iris.config.accessToken
                };
                if ($scope.file.ownerId) item.url += '?ownerId=' + $scope.file.ownerId;
            }
        });
    }]);
})();
'use strict';

(function () {
    angular.module('irisApp').controller('DmsZipUploadCtrl', ["$scope", "$window", "$uibModal", "$uibModalInstance", "$translate", "projects", "targetFolderId", "FileUploader", "FoldersService", "WorkflowService", "format", function ($scope, $window, $uibModal, $uibModalInstance, $translate, projects, targetFolderId, FileUploader, FoldersService, WorkflowService, format) {
        $scope.projects = projects;
        $scope.targetFolderId = targetFolderId;
        $scope.zip = {};

        $scope.$watch("zip", setParams, true);

        $scope.workflows = [];
        $scope.uploadWorkflows = function (projectId) {
            $scope.workflows = [];
            if (!projectId) return;
            WorkflowService.getWorkflows(projectId).then(function (workflows) {
                return $scope.workflows = workflows;
            });
        };

        if (targetFolderId != 'root') {
            FoldersService.getById(targetFolderId).$promise.then(function (folder) {
                return $scope.uploadWorkflows(folder.projectId);
            });
        }

        function setParams() {
            if (!$scope.uploader || !$scope.uploader.queue || !$scope.uploader.queue.length) return;

            var file = $scope.uploader.queue[0];
            file.url = FoldersService.getZipImportUrl($scope.targetFolderId, format);

            if ($scope.zip.projectId) file.url += '&projectId=' + $scope.zip.projectId;
            if ($scope.zip.comment) file.url += '&comment=' + $window.encodeURIComponent($scope.zip.comment);

            var workflowId = $scope.zip.workflowId;
            if (!workflowId) return;

            var workflow = $scope.workflows.filter(function (w) {
                return w.id == workflowId;
            })[0];
            if (!workflow) return;

            var startState = workflow.workflowStates.filter(function (s) {
                return s.type == 'START';
            })[0];
            var startStateId = startState ? startState.id : null;

            file.url += '&workflowId=' + workflowId + (startStateId ? '&workflowStateId=' + startStateId : '');
        }

        $scope.uploader = new FileUploader({
            url: FoldersService.getZipImportUrl($scope.targetFolderId, format),
            queueLimit: 1,
            onErrorItem: function onErrorItem(fileItem, response, status, headers) {
                alertify.error($translate.instant(format == 'ZIP' ? 'text.dms.ZipFolderUploadError' : 'text.dms.XlsFolderUploadError'));
                $scope.hasErrors = true;
            },
            onCompleteAll: function onCompleteAll() {
                if (!$scope.hasErrors) alertify.success($translate.instant(format == 'ZIP' ? 'text.dms.ZipFolderUploadSuccess' : 'text.dms.XlsFolderUploadSuccess'));
                $uibModalInstance.close();
            }
        });
    }]);
})();
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function () {
    angular.module('irisApp').controller('DmsFilesBaseCtrl', ["$scope", "$uibModal", "$filter", "$timeout", "$interpolate", "$translate", "workflowsFull", "FilesService", "TasksService", "$stateParams", "$window", function ($scope, $uibModal, $filter, $timeout, $interpolate, $translate, workflowsFull, FilesService, TasksService, $stateParams, $window) {
        $scope.selected_file = null;
        $scope.workflowsFull = workflowsFull;
        $scope.permissions = {
            inherit: false
        };

        $scope.getSelectedFilesIds = function () {
            var selected_files_ids = [];
            var selected_files = $filter('filter')($scope.files, { selected: true });
            for (var i = 0, c = selected_files.length; i < c; i++) {
                var file = selected_files[i];
                selected_files_ids.push(file.id);
            }
            return selected_files_ids;
        };

        $scope.getFileIcon = function (mime_type) {
            return FilesService.getIcon(mime_type);
        };

        $scope.getFileDownloadUrl = function (file_id) {
            return FilesService.getFileDownloadUrl(file_id);
        };

        $scope.getAttachmentDownloadUrl = function (file_id, attachment_id) {
            return FilesService.getAttachmentDownloadUrl(file_id, attachment_id);
        };

        $scope.getTaskUrl = function (task) {
            return TasksService.getTaskViewUrl(task.id);
        };

        $scope.updateSelectedFile = function (file) {
            if (!$scope.selected_file && !file) return;
            if (file) $scope.selected_file = file;

            if ($scope.selected_file.attachedIn && $scope.selected_file.attachedIn.length) {
                $scope.selected_file.tasks = [];
                TasksService.getByFile($scope.selected_file.id).then(function (tRes) {
                    $scope.selected_file.tasks = tRes;
                });
            }

            var fileWorkflow = $scope.workflowsFull.filter(function (w) {
                return w.id == $scope.selected_file.workflowId;
            });
            if (fileWorkflow.length === 1) {
                var fileWorkflowState = fileWorkflow[0].workflowStates.filter(function (s) {
                    return s.id == $scope.selected_file.workflowStateId;
                });
                if (fileWorkflowState.length === 1) {
                    $scope.selected_file.workflowState = fileWorkflowState[0];
                    $scope.selected_file.workflowStateValid = fileWorkflowState[0].mergedUsers.filter(function (u) {
                        return u.id == iris.config.me.id;
                    }).length > 0;
                } else {
                    delete $scope.selected_file.workflowState;
                    delete $scope.selected_file.workflowStateValid;
                }
            }

            $scope.selected_file.versions = $filter('filter')($scope.selected_file.history, { action: "label.dms.Upload" }, true);
            $scope.sidebar.file_tab = 'info';

            $scope.selected_file.previewType = FilesService.getPreviewType($scope.selected_file);
            if ($scope.selected_file.previewType !== null) {
                //Math.random is needed here to update preview if new image was uploaded (url is not changed otherwise)
                $scope.selected_file.previewLink = FilesService.getFilePreviewUrl($scope.selected_file.id) + '&version=' + Math.random(1000);
            }

            //Update selected_file.history array by adding params to display an event and also date for sorting
            $scope.selected_file.history.forEach(function (h) {
                h.params = !h.args ? {} : h.args.reduce(function (res, next, i) {
                    res['p' + i] = next;
                    return res;
                }, {});
                h.date = new Date(h.updatedOn).setHours(0, 0, 0, 0);
            });

            var url = $interpolate(location.origin + "{{page}}/folders/{{folderId}}/files?file={{fileId}}")({
                page: iris.config.pageUrl,
                folderId: $scope.selected_file.parentId,
                fileId: $scope.selected_file.id
            });
            $scope.selected_file_dms_link = url;

            $scope.changeShowAllPreview = false;
            if ($scope.selected_file.thumbId) $scope.selected_file.thumbLink = FilesService.getFilePreviewUrl($scope.selected_file.thumbId) + '&version=' + Math.random(1000);

            $scope.filesCommentsApiUrl = FilesService.getFilesCommentsApiUrl($scope.selected_file);
        };

        $scope.setSelectedFile = function (file) {
            $scope.selected_file = $scope.sidebar.is_file_info_shown && $scope.selected_file && $scope.selected_file.id == file.id ? null : file;
            $scope.sidebar.is_file_info_shown = !!$scope.selected_file;

            if ($stateParams.tab) $timeout(function () {
                $('#' + $stateParams.tab + ' a').click();
            }, 500);

            var department = $scope.selected_file && $scope.selected_file.tags.find(function (e) {
                return e.type == "Department";
            }) || null;
            if (department) {
                department.name = $scope.getFullDepartmentName(department.value);
            }

            if ($scope.selected_file) $scope.updateSelectedFile();
        };

        $scope.getFullDepartmentName = function (id) {
            if (id) {
                var _ret = function () {
                    var currentNode = iris.data.departments.find(function (d) {
                        return d.id == id;
                    }),
                        fullDescription = '';
                    while (currentNode) {
                        fullDescription = '' + currentNode.name + (fullDescription ? ' > ' : '') + fullDescription;
                        currentNode = iris.data.departments.find(function (d) {
                            return d.id == currentNode.parentId;
                        });
                    }
                    return {
                        v: fullDescription
                    };
                }();

                if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
            }
        };

        $scope.selectFile = function (entity) {
            var index = $scope.files.findIndex(function (f) {
                return f.id === entity.id;
            });
            if (index !== -1) $scope.files[index].selected = !$scope.files[index].selected;
            $scope.$emit('selectFileInGrid');
        };

        $scope.openPreviewFile = function (file, version) {
            if (version) {
                FilesService.openPreviewVersion(file.id, version.id, file);
            } else {
                FilesService.openPreviewFile(file.id, file);
            }
        };

        $scope.$on('getSelectedFilesDownloadUrl', function () {
            $window.location.href = $scope.getSelectedFilesDownloadUrl();
        });

        $scope.getSelectedFilesDownloadUrl = function () {
            return FilesService.getSelectedFilesDownloadUrl($scope.getSelectedFilesIds());
        };

        $scope.getVersionDownloadUrl = function (file, version) {
            return FilesService.getVersionDownloadUrl(file.id, version.id);
        };
    }]);
})();
'use strict';

(function () {
    angular.module('irisApp').controller('DMSFilesChangeGridViewCtrl', ["$rootScope", "$scope", "$uibModalInstance", "dmsGridConfig", "UserSettingsService", "DmsGridConfigurationService", function ($rootScope, $scope, $uibModalInstance, dmsGridConfig, UserSettingsService, DmsGridConfigurationService) {
        $scope.defaultColDefs = DmsGridConfigurationService.applyColumnsSettings(dmsGridConfig);

        $scope.sortableOptions = {
            items: "li:not(.locked)"
        };

        $scope.changeVisibility = function (column) {
            $scope.dmsGridConfig.settings.columns.find(function (c) {
                return c.name === column.name;
            }).visible = column.visible;
        };

        $scope.save = function () {

            dmsGridConfig.settings = dmsGridConfig.settings || {};
            dmsGridConfig.settings.columns = $scope.defaultColDefs.map(function (c, i) {
                return { name: c.name, order: i, visible: c.visible };
            });

            UserSettingsService.saveUserSettings('dms-grid-config-vmodal5', dmsGridConfig, iris.config.me.id).then(function (res) {
                $uibModalInstance.close(res);
            });
        };

        $scope.toDefaultView = function () {
            $scope.defaultColDefs = DmsGridConfigurationService.applyColumnsSettings();
        };
    }]);
})();
'use strict';

(function () {
    angular.module('irisApp').controller('DmsFilesCommonCtrl', ["$scope", "FoldersSecurityService", "$filter", "FilesService", "WorkflowService", "$translate", "SecurityService", "FoldersService", function ($scope, FoldersSecurityService, $filter, FilesService, WorkflowService, $translate, SecurityService, FoldersService) {

        $scope.folder_permissions = [];

        $scope.hasPermission = function (folder_id, action, subject_name) {
            subject_name = subject_name || 'iris:repoContentFolder';
            return SecurityService.hasPermissions(folder_id, subject_name, action);
        };

        $scope.previewAllowed = function (file) {
            return FilesService.previewAllowed(file);
        };

        $scope.getFileIcon = function (mime_type) {
            return FilesService.getIcon(mime_type);
        };

        $scope.getFolderPermissions = function (folder) {
            FoldersSecurityService.getFolderPermissions(folder.id).then(function (permissions) {
                $scope.folder_permissions = permissions;
            });
        };

        $scope.openPreviewFile = function (file) {
            FilesService.openPreviewFile(file.id, file);
        };

        $scope.updateFolder = function (folder_id) {
            return FoldersService.getById(folder_id || $scope.folder.id).$promise.then(function (folder) {
                $scope.folder = folder;
                $scope.workflows = [];
                if (folder.projectId) {
                    WorkflowService.getWorkflowsByType(folder.projectId, 'DOCUMENT').then(function (workflows) {
                        $scope.workflows = workflows.filter(function (w) {
                            return !!w.workflowStates.length;
                        });
                    });
                }
                $scope.$emit('dms.folder.content-changed');
            });
        };

        $scope.applyFilesFilter = function () {
            $scope.filtered_files = $scope.filter && $scope.filter.text != null ? $filter('filter')($scope.files, { name: $scope.filter.text }) : $scope.files;
        };

        $scope.updateWithFiles = function (files) {
            var is_file_selected = false;
            for (var i = 0, c = files.length; i < c; i++) {
                if ($scope.selected_file && files[i].id == $scope.selected_file.id) {
                    $scope.selected_file = files[i];
                    $scope.updateSelectedFile();
                    is_file_selected = true;
                    break;
                }
            }
            if ($scope.selected_file && !is_file_selected) $scope.setSelectedFile($scope.selected_file);
            $scope.files = files;
            $scope.applyFilesFilter();
        };

        $scope.updateFolderFiles = function (folder_id) {
            console.log("updateFolderFiles");

            FilesService.getFolderFiles(folder_id || $scope.folder.id).then(function (files) {
                $scope.updateWithFiles(files);
            });
            $scope.updateFolder(folder_id);
        };

        $scope.getFilePrintUrl = function (f) {
            return '/ui/ui/dms/files/' + f.id + '/comments-print';
        };
        $scope.getFolderPrintUrl = function (f) {
            return '/ui/ui/dms/folders/' + f.id + '/comments-print';
        };
        $scope.getPrintCommentsFileName = function (itemName) {
            return 'comments_to_' + itemName;
        };
    }]);
})();
'use strict';

(function () {
    angular.module('irisApp').controller('DmsFilesCtrl', ["$scope", "$window", "$state", "$q", "$timeout", "$filter", "$uibModal", "$translate", "$controller", "$stateParams", "files", "folder", "projects", "workflows", "localIp", "FoldersService", "FoldersSecurityService", "MailService", "UserGroupsService", "FilesService", "WorkflowService", "CompaniesService", "DmsMapsService", "LangList", "DmsAppService", "FileUploader", "UserSettingsService", "DmsActions", "DmsGridConfigurationService", function ($scope, $window, $state, $q, $timeout, $filter, $uibModal, $translate, $controller, $stateParams, files, folder, projects, workflows, localIp, FoldersService, FoldersSecurityService, MailService, UserGroupsService, _FilesService, WorkflowService, CompaniesService, DmsMapsService, LangList, DmsAppService, FileUploader, UserSettingsService, DmsActions, DmsGridConfigurationService) {

        angular.extend($scope, $controller('WebSocketMixin', { $scope: $scope }));
        angular.extend($scope, $controller('DmsFilesBaseCtrl', { $scope: $scope, workflowsFull: workflows }));
        angular.extend($scope, $controller('DmsFilesCommonCtrl', { $scope: $scope }));

        $scope.gridIsRender = true;

        $scope.localIp = localIp;
        $scope.appState = {
            ip: localIp,
            active: false
        };

        if (!folder) {
            $state.go('dms.folders');
        }
        if (folder.isTrashBin) $scope.sidebar.showSystemFolders = true;

        console.log(folder.id, localIp, iris.config.me.id);

        var department = folder && folder.tags && folder.tags.find(function (e) {
            return e.type == "Department";
        }) || null;
        if (department) {
            department.name = $scope.getFullDepartmentName(department.value);
        }

        $scope.webSocket.connect('/websocket').subscribe('/global-broker/dms/folders/' + folder.id + '/files', function (response) {
            // filter out broadcasts that were caused by own actions
            $timeout(function () {
                console.log("Updates on folder " + folder.name + " by user " + response.user + " received.");
                var files = [];
                response.files.forEach(function (file) {
                    files.push(_FilesService.createFile(file));
                });
                $scope.updateWithFiles(files);
            });
        }).subscribe('/user-broker/' + iris.config.me.id + '/dms/app-subscribe/' + localIp, function (response) {
            // filter out broadcasts that were caused by own actions
            $timeout(function () {
                console.log("DMSApp subscribed " + response.subscribed + " by user " + response.user + " received.");
                $scope.appState.active = response.subscribed;
            });
        });

        $scope.$on('$destroy', function () {
            if ($scope.webSocket) {
                console.log("Unsubscribe folder " + folder.name);
                $scope.webSocket.unsubscribe('/global-broker/dms/folders/' + folder.id + '/files');
                $scope.webSocket.unsubscribe('/user-broker/' + iris.config.me.id + '/dms/app-subscribe/' + localIp);
            }
        });
        $scope.permissions = {
            inherit: false,
            companyId: "all" //iris.config.me.profile && iris.config.me.profile.companyId ? iris.config.me.profile.companyId : null
        };
        $scope.companies = [];
        CompaniesService.getCompanies().$promise.then(function (companies) {
            $scope.companies = companies;
            $scope.companies.push({ id: "all", name: $translate.instant('label.dms.AllUserGroups') });
            $scope.companies.push({ id: "none", name: $translate.instant('label.dms.WithoutCompany') });
        });

        $scope.workflows = workflows.filter(function (w) {
            return !!w.workflowStates.length;
        });
        $scope.files = files;
        $scope.projects = projects;
        $scope.filtered_files = $scope.files;
        $scope.folder = folder;
        $scope.$emit('selectFolder');
        $scope.folder.fileCount = FoldersService.getFolderFilesCount($scope.folder);
        if ($scope.folder.isTrashBin) $scope.sidebar.showSystemFolders = true;

        if ($stateParams.file) {
            var file = files.find(function (f) {
                return f.id == $stateParams.file;
            });
            if (file) $scope.setSelectedFile(file);
        } else $scope.selected_file = null;

        $scope.all_folders = FoldersService.getAllFoldersList();

        $scope.currentUser = iris.config.me;
        $scope.breadcrumbs.pathFolders = FoldersService.getPathFolders(folder);
        $scope.breadcrumbs.path = '';
        for (var i = 0, l = $scope.breadcrumbs.pathFolders.length; i < l; i++) {
            $scope.breadcrumbs.path += $scope.breadcrumbs.pathFolders[i].name;
            if (i !== l - 1) $scope.breadcrumbs.path += ' > ';
        }

        $scope.actions = FoldersSecurityService.getDMSSecurityActions();

        $scope.user_groups = [];
        UserGroupsService.getUserGroups().$promise.then(function (groups) {
            $scope.user_groups = groups;
        });

        $scope.changeShowAllPreview = false;

        $scope.getFolderPermissions($scope.folder);

        $scope.getUserGroups = function () {
            //var filterCompanyId = $scope.permissions.companyId === "all" ? $scope.projects.filter(p => p.id == $scope.folder.projectId)[0].companyId : $scope.permissions.companyId;
            //return $scope.user_groups.filter(g => g.companyId == filterCompanyId);
            if ($scope.permissions.companyId === "all") return $scope.user_groups;
            return $scope.user_groups.filter(function (g) {
                return $scope.permissions.companyId === "none" && g.companyId == null || g.companyId == $scope.permissions.companyId;
            });
        };

        $scope.updateAppState = function () {
            var defer = $q.defer();
            DmsAppService.checkAppState(localIp).then(function (state) {
                $scope.appState.active = state.isInstalled;
                defer.resolve($scope.appState);
            });
            return defer.promise;
        };
        $scope.updateAppState();

        $scope.setPermission = function (user_group_id, action, permission) {
            //if permission exists - remove, otherwise update
            //todo refactor if performance needed
            if ($scope.hasFolderPermission(user_group_id, action) == permission) {
                var perm = getPermByUGAndAction(user_group_id, action);
                FoldersSecurityService.removePermission(perm.id, $scope.permissions.inherit).then(function () {
                    $scope.getFolderPermissions($scope.folder);
                });
            } else {
                FoldersSecurityService.setPermission($scope.folder.id, user_group_id, action, permission, $scope.permissions.inherit).then(function () {
                    $scope.getFolderPermissions($scope.folder);
                });
            }
        };

        $scope.hasFolderPermission = function (user_group_id, action) {
            var permission = getPermByUGAndAction(user_group_id, action);

            if (!permission) return;

            return permission.allowed;
        };

        var getPermByUGAndAction = function getPermByUGAndAction(user_group_id, action) {
            var user_group_permissions = $filter('filter')($scope.folder_permissions, { id: user_group_id }, true);

            if (!user_group_permissions || !user_group_permissions.length) return;

            var subject = user_group_permissions[0].subjects[0];

            var action_permissions = $filter('filter')(subject.permissions, { action: action }, true);

            if (!action_permissions || !action_permissions.length) return;

            return action_permissions[0];
        };

        $scope.$on('dms.folder.modified', function () {
            $scope.updateFolder();
        });
        $scope.$on("dms.files.moved", function () {
            $scope.updateFolderFiles();
        });

        $scope.$watch('filter.text', $scope.applyFilesFilter);

        $scope.getFileWorkflowColor = function (file) {
            var workflow = workflows.filter(function (w) {
                return w.id == file.workflowId;
            });
            return workflow.length ? workflow[0].color : null;
        };

        function updateUserSettigns() {
            UserSettingsService.saveUserSettings('dms-grid-config-vmodal5', $scope.dmsGridConfig, iris.config.me.id);
        }

        $scope.setActionsVisibility = function (action) {
            var actions = $scope.dmsGridConfig.settings.actions;
            actions[action] = !actions[action];
            updateUserSettigns();
        };

        $scope.gridOptions = {
            data: 'filtered_files',
            minRowsToShow: 100,
            enableFullRowSelection: false,
            enableSelectAll: true,
            selectionRowHeaderWidth: 35,
            multiSelect: true,
            columnDefs: !$scope.folder.isTrashBin ? $scope.dmsGridDefaultColDefs : $scope.filesGridIsTrashDefaultColDefs,
            rowTemplate: '<div ng-repeat="(colRenderIndex, col) in colContainer.renderedColumns track by col.colDef.name"\n                               class="ui-grid-cell"\n                               ng-class="{ \'ui-grid-row-header-cell\': col.isRowHeader, \'row-selected\':row.entity.id == grid.appScope.selected_file.id}"\n                               ui-grid-cell></div>',
            onRegisterApi: function onRegisterApi(gridApi) {
                $scope.gridOptions.gridAPI = gridApi;

                gridApi.selection.on.rowSelectionChanged($scope, function (row, event) {
                    $scope.selectFile(row.entity);
                });

                gridApi.selection.on.rowSelectionChangedBatch($scope, function (rows) {
                    for (var i in rows) {
                        $scope.selectFile(rows[i].entity);
                    }
                });

                //After going to folder from search result - select file
                if ($stateParams.file) {
                    $timeout(function () {
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = files[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var file = _step.value;

                                if (file.id == $stateParams.file) {
                                    $scope.gridOptions.gridAPI.selection.selectRow(file);
                                    break;
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    });
                }
            }
        };

        $scope.restore = function (fileId) {
            iris.loader.start('.app-content');
            _FilesService.restore(fileId).then(function () {
                $scope.updateFolder().then(function () {
                    $scope.filtered_files.splice($scope.filtered_files.findIndex(function (f) {
                        return f.id == fileId;
                    }), 1);
                    iris.loader.stop('.app-content');
                });
            });
        };

        $scope.previewAllowed = function (file) {
            return _FilesService.previewAllowed(file);
        };

        $scope.openPreviewAttachment = function (file, attachment) {
            var urls = {
                previewUrl: _FilesService.getAttachmentPreviewUrl(file.id, attachment.id),
                downloadUrl: _FilesService.getAttachmentDownloadUrl(file.id, attachment.id)

            };
            _FilesService.openPreviewFile(attachment.id, attachment, urls);
        };

        $scope.moveAttachmentToCurrentFolder = function (file_id, attachment_id, target_folder_id) {
            iris.loader.start('.app-content');
            _FilesService.copyAttachmentToFolder(file_id, attachment_id, target_folder_id, true).then(function () {
                $scope.updateFolder().then(function () {
                    iris.loader.stop('.app-content');
                });
            });
        };

        $scope.openEditFileLocal = function (file) {
            iris.loader.start('.app-content');
            $scope.updateAppState().then(function (state) {
                if (!state.active) {
                    alertify.error($translate.instant('label.dms.CheckoutPluginNotRunning'));
                    return;
                }
                _FilesService.localEdit(file.id, $scope.localIp).then(function (file) {
                    iris.loader.stop('.app-content');
                });
            });
        };

        //Open full path to selected folder
        FoldersService.expandToFolder(folder);

        $scope.openUploaderForm = function () {
            $uibModal.open({
                templateUrl: iris.config.moduleUrl + '/templates/dms.uploader.html',
                controller: 'DmsFilesUploadCtrl',
                resolve: {
                    'folder': function folder() {
                        return $scope.folder;
                    },
                    'workflows': function workflows() {
                        return $scope.workflows;
                    },
                    'folderFiles': function folderFiles() {
                        return _FilesService.getFolderFiles(folder.id);
                    },
                    'users': function users() {
                        return iris.data.usersInfo;
                    },
                    'languages': function languages() {
                        return LangList.query();
                    },
                    'dmsConfig': function dmsConfig() {
                        return angular.copy($scope.dmsConfig);
                    }
                },
                size: 'xl'
            }).result.then(function () {
                $scope.updateFolderFiles();
            });
        };

        $scope.$on('openUploaderForm', function () {
            $scope.openUploaderForm();
        });

        $scope.openChangeStateModal = function (_file) {
            if (!_file.workflowId) return;

            $uibModal.open({
                templateUrl: iris.config.moduleUrl + '/templates/dms.file.workflow.change-state.modal.html',
                controller: 'DmsFileChangeWfStateCtrl',
                resolve: {
                    'file': function file() {
                        return _file;
                    },
                    'workflowStates': ["WorkflowService", function (WorkflowService) {
                        if (!_file.workflowId) return [];

                        return _file.workflowStateId ? WorkflowService.getWorkflowNextStates(_file.workflowId, _file.workflowStateId) : WorkflowService.getWorkflowStates(_file.workflowId);
                    }]
                }
            }).result.then(function () {
                $scope.updateFolderFiles();
            });
        };

        function removeAction(file, isFroce) {
            DmsActions.execute("removeFile", {
                file: file,
                isForce: isFroce,
                onAfterAction: function onAfterAction() {
                    return $scope.updateFolderFiles();
                }
            });
        }

        $scope.removeFile = function (file) {
            alertify.confirm($translate.instant('text.dms.FileRemoveConfirm'), function (e) {
                if (e) {
                    if (file && file.attachedIn && file.attachedIn.length) {
                        alertify.confirm($translate.instant('text.dms.AttachedFileRemoveConfirm'), function (e) {
                            if (e) removeAction(file, true);
                        });
                    } else removeAction(file);
                }
            });
        };

        $scope.openEditFile = function (_file2) {
            $uibModal.open({
                templateUrl: iris.config.moduleUrl + '/templates/dms.files.edit.html',
                controller: 'DmsFileEditCtrl',
                resolve: {
                    'file': function file() {
                        return _file2;
                    },
                    'workflows': function workflows() {
                        return $scope.workflows;
                    },
                    'users': function users() {
                        return iris.data.usersInfo;
                    },
                    'languages': function languages() {
                        return LangList.query();
                    },
                    'dmsConfig': function dmsConfig() {
                        return angular.copy($scope.dmsConfig);
                    }
                }
            }).result.then(function () {
                $scope.updateFolderFiles();
            });
        };

        $scope.openUploadNewVersion = function (_file3) {
            $uibModal.open({
                templateUrl: iris.config.moduleUrl + '/templates/docs.uploadNewVersion.html',
                controller: 'DmsFileUploadCtrl',
                resolve: {
                    'file': function file() {
                        return _file3;
                    }
                }
            }).result.then(function () {
                $scope.updateFolderFiles();
            });
        };

        function openSelectFolderModal(label) {
            return $uibModal.open({
                templateUrl: iris.config.moduleUrl + '/templates/dms.files.move.html',
                controller: 'DmsFileMoveCtrl',
                size: 'sm',
                resolve: {
                    'folder': function folder() {
                        return $scope.folder;
                    },
                    'enable_root': function enable_root() {
                        return false;
                    },
                    'is_folder_moved': function is_folder_moved() {
                        return false;
                    },
                    'action_label': function action_label() {
                        return label || 'label.Move';
                    }
                }
            }).result;
        }

        $scope.openMoveFiles = function (file) {
            DmsActions.execute("moveFiles", {
                folder: $scope.folder,
                fileIds: !file ? $scope.getSelectedFilesIds() : [file.id],
                onAfterAction: function onAfterAction() {
                    return $scope.updateFolderFiles();
                }
            });
        };

        $scope.$on('openMoveFiles', function () {
            $scope.openMoveFiles();
        });

        $scope.openCopyFiles = function (file) {
            var selected_files_ids = !file ? $scope.getSelectedFilesIds() : [file.id];
            openSelectFolderModal("label.Copy").then(function (target_folder) {
                iris.loader.start();
                var promises = selected_files_ids.map(function (fileId) {
                    return _FilesService.copyToFolder(fileId, target_folder.id);
                });
                $q.all(promises).then(function () {
                    alertify.success($translate.instant('label.dms.FilesCopied'));
                    $scope.updateFolderFiles();
                    iris.loader.stop();
                });
            });
        };

        $scope.$on('openCopyFiles', function () {
            $scope.openCopyFiles();
        });

        $scope.toggleLockedFile = function (file) {
            _FilesService.toggleLockedFile(file).then(function (file) {
                $scope.file = file;
                $scope.updateSelectedFile();
            });
        };

        $scope.shareFile = function (_file4) {
            $uibModal.open({
                templateUrl: iris.config.moduleUrl + '/templates/dms.files.share.html',
                controller: 'DmsFileShareModalCtrl',
                resolve: {
                    'file': function file() {
                        return _file4;
                    },
                    'FilesService': function FilesService() {
                        return _FilesService;
                    }
                }
            });
        };

        $scope.openToggleInProgress = function (file) {
            $scope.updateAppState();
            $uibModal.open({
                templateUrl: iris.config.moduleUrl + '/templates/dms.files.toggle-in-progress.html',
                controller: 'DmsFileToggleInProgressModalCtrl',
                scope: $scope,
                resolve: {
                    'dmsAppState': ["DmsAppService", function (DmsAppService) {
                        return DmsAppService.getIP().then(function (ip) {
                            //console.log(ip);
                            ip = '172.17.42.1';
                            return DmsAppService.checkAppState(ip).then(function (state) {
                                //console.log(state);
                                return {
                                    ip: ip,
                                    active: state.isInstalled
                                };
                            });
                        });
                    }]
                }
            }).result.then(function (isOpenUpload) {
                if (isOpenUpload) $scope.openUploadNewVersion($scope.selected_file);
            });
        };

        $scope.openWorkflowStatesDiagram = function (workflowId) {
            $uibModal.open({
                templateUrl: iris.config.componentsUrl + '/global-settings/templates/workflows/ms.workflows.workflow.states.diagram.html',
                controller: 'ModuleWorkflowStatesDiagramCtrl',
                size: 'lg',
                resolve: {
                    'states': ["WorkflowService", function (WorkflowService) {
                        return WorkflowService.getWorkflowStates(workflowId);
                    }]
                }
            });
        };

        $scope.removeSelectedFiles = function () {
            alertify.confirm($translate.instant('text.dms.FilesRemoveConfirm'), function (e) {
                if (e) {
                    DmsActions.execute("removeFiles", {
                        files: $scope.files,
                        onAfterAction: function onAfterAction() {
                            return $scope.updateFolderFiles();
                        }
                    });
                }
            });
        };

        $scope.$on('removeSelectedFiles', function () {
            $scope.removeSelectedFiles();
        });

        $scope.openSendMessageModal = function () {
            iris.loader.start('.app-body');

            var selected_files = $scope.gridOptions.gridAPI.selection.getSelectedRows();

            MailService.openSendMailModal(null, selected_files);
        };

        $scope.$on('openSendMessageModal', function () {
            $scope.openSendMessageModal();
        });

        $scope.getWorkflowStateName = function (workflowId, workflowStateId) {
            var workflows = $scope.workflows.filter(function (w) {
                return w.id == workflowId;
            });
            if (!workflows.length) return;

            var workflowStates = workflows[0].workflowStates.filter(function (s) {
                return s.id == workflowStateId;
            });
            if (!workflowStates.length) return;

            return workflowStates[0].name;
        };

        $scope.hasLinkToMaps = function (file) {
            if (file && file.layerId && file.markerId) {
                if (!file.markerNotFound && !file.goToMapsLink) {
                    /* first time call with given file */
                    file.markerNotFound = true;
                    DmsMapsService.requestLayerById(file.layerId).then(function (layer) {
                        DmsMapsService.requestMarkerById(file.layerId, file.markerId).then(function (marker) {
                            if (marker.layer_id == file.layerId) {
                                file.goToMapsLink = _FilesService.goToMaps(layer, marker);
                                file.markerNotFound = false;
                            }
                        });
                    });
                }
                return !file.markerNotFound && file.goToMapsLink;
            }
            return false;
        };

        $scope.goToMaps = function (file) {
            $window.open(file.goToMapsLink, '_blank');
        };

        $scope.refreshUrl = function (file) {
            $timeout(function () {
                file.url = FoldersService.getUploadUrl(folder);

                if (file.ownerId) {
                    file.url += (file.url.indexOf("?") > 0 ? "&" : "?") + ('ownerId=' + file.ownerId);
                }

                $scope.uploader.uploadAll();
            });
        };

        $scope.uploader = new FileUploader({
            url: FoldersService.getUploadUrl(folder),
            onAfterAddingFile: function onAfterAddingFile(item) {
                iris.loader.start('.app-body-container');
                item.ownerId = iris.config.me.id;
                $scope.refreshUrl(item);
            },
            onErrorItem: function onErrorItem(fileItem, response, status, headers) {
                iris.loader.stop();
                alertify.error($translate.instant('text.dms.FileUploadedError') + ": " + fileItem.file.name);
                $scope.hasErrors = true;
            },
            onCompleteAll: function onCompleteAll() {
                iris.loader.stop();
                $scope.$broadcast('dms.folder.modified');
                if (!$scope.hasErrors) alertify.success($translate.instant('text.dms.FilesUploadedSuccess'));
            }
        });

        $scope.openPreviousVersionsModal = function (_folder, _file5) {
            return $uibModal.open({
                templateUrl: iris.config.moduleUrl + '/templates/dms.files.previous-versions.html',
                size: 'lg',
                controller: 'DmsPreviousVersionsCtrl',
                resolve: {
                    'file': function file() {
                        return _file5;
                    },
                    'folder': function folder() {
                        return _folder;
                    }
                }
            }).result;
        };

        $scope.toggleAsFavorite = function (file_id) {
            _FilesService.toggleFavorite(file_id).then(function (file) {
                $scope.filtered_files[$scope.filtered_files.findIndex(function (f) {
                    return f.id === file.id;
                })] = file;
            });
        };

        $scope.copyAttachmentToFolder = function (file_id, id) {
            openSelectFolderModal('label.dms.CopyToFolder').then(function (target_folder) {
                iris.loader.start('.app-content');
                _FilesService.copyAttachmentToFolder(file_id, id, target_folder.id, true).then(function () {
                    $scope.updateFolder(target_folder.id);
                    iris.loader.stop('.app-content');
                });
            });
        };

        $scope.removeAttachment = function (file_id, id) {
            alertify.confirm($translate.instant('text.dms.FileRemoveConfirm'), function (e) {
                if (e) {
                    _FilesService.removeAttachment(file_id, id).then(function () {
                        $scope.selected_file.attachments.splice($scope.selected_file.attachments.findIndex(function (a) {
                            return a.id === id;
                        }), 1);
                        alertify.success($translate.instant('label.dms.FileRemoved'));
                    });
                }
            });
        };

        $scope.$on('updateFilesGrid', function (params) {
            $scope.gridOptions.columnDefs = DmsGridConfigurationService.applyColumnsSettings(params.targetScope.dmsGridConfig);
            $scope.gridOptions.gridAPI.core.refresh();
        });

        $scope.changeShowAll = function () {
            $scope.changeShowAllPreview = !$scope.changeShowAllPreview;
        };
    }]);
})();
'use strict';

(function () {
    angular.module('irisApp').controller('DmsPreviousVersionsCtrl', ["$scope", "file", "$translate", "FilesService", "$filter", "FoldersSecurityService", "folder", "$controller", function ($scope, file, $translate, FilesService, $filter, FoldersSecurityService, folder, $controller) {

        angular.extend($scope, $controller('DmsFilesCommonCtrl', { $scope: $scope }));

        $scope.file = file;
        $scope.folder = folder;
        $scope.versions = $filter('orderBy')($scope.file.versions, '-updatedOn');
        $scope.versionsLength = $scope.file.versions.length;

        $scope.openPreviewVersion = function (file, version) {
            FilesService.openPreviewVersion(file.id, version.id, file);
        };

        $scope.getFolderPermissions($scope.folder);

        $scope.getVersionDownloadUrl = function (file, version) {
            return FilesService.getVersionDownloadUrl(file.id, version.id);
        };

        $scope.removeVersion = function (folder_id, file, version) {
            alertify.confirm($translate.instant('text.dms.FileVersionRemoveConfirm'), function (e) {
                if (e) {
                    FilesService.removeVersion(file.id, version.id).then(function () {
                        alertify.success($translate.instant('label.dms.FileVersionRemoved'));
                        $scope.versions.splice($scope.versions.findIndex(function (v) {
                            return v.id == version.id;
                        }), 1);
                        $scope.versionsLength--;
                        $scope.updateFolderFiles(folder_id);
                    });
                }
            });
        };

        $scope.gridOptions = {
            data: 'versions',
            onRegisterApi: function onRegisterApi(gridApi) {
                $scope.gridOptions.gridAPI = gridApi;
            },
            columnDefs: [{
                field: 'id',
                width: '*',
                displayName: $translate.instant('label.Version'),
                enableSorting: false,
                cellTemplate: '\n                        <div class="ui-grid-cell-contents actions">\n                            v{{grid.appScope.versionsLength - rowRenderIndex}}\n                        </div>'
            }, {
                field: 'filename',
                width: '**',
                displayName: $translate.instant('label.Name'),
                enableSorting: false,
                cellTemplate: '\n                        <div class="ui-grid-cell-contents actions">\n                            <a href="javascript:void(0)" uib-tooltip="{{row.entity.name}}">\n                                <i class="fa fa-fw {{::grid.appScope.getFileIcon(row.entity.mimeType)}}"></i> {{row.entity.filename}}\n                            </a>\n                        </div>'
            }, {
                field: 'updatedOn',
                width: 120,
                displayName: $translate.instant('label.UpdatedOn'),
                enableSorting: false,
                cellFilter: 'irisTime:grid.appScope'
            }, {
                field: 'updatedBy',
                width: 200,
                displayName: $translate.instant('label.UpdatedBy'),
                enableSorting: false
            }, {
                name: 'actions',
                displayName: $translate.instant('label.Actions'),
                enableSorting: false,
                width: 100,
                cellTemplate: '\n                        <div class="ui-grid-cell-contents actions">\n                            <a href="{{grid.appScope.getVersionDownloadUrl(grid.appScope.file, row.entity)}}" class="btn btn-link btn-sm"\n                                uib-tooltip="{{\'label.dms.ClickToDownload\' | translate}}">\n                                <i class="fa fa-download"></i>\n                            </a>\n                            <button ng-click="grid.appScope.openPreviewVersion(grid.appScope.file, row.entity)"\n                                    class="btn btn-link btn-sm" \n                                    ng-show="grid.appScope.previewAllowed(grid.appScope.file)"\n                                    uib-tooltip="{{\'label.Preview\' | translate}}">\n                                <i class="fa fa-eye"></i>\n                            </button>\n                            <button ng-click="grid.appScope.removeVersion(grid.appScope.folder.id, grid.appScope.file, row.entity); $event.preventDefault(); $event.stopPropagation();"\n                                ng-if="grid.appScope.hasPermission(grid.appScope.folder.id, \'delete\') || grid.appScope.hasPermission(\'DMS\', \'config\', \'Module\')"\n                                ng-disabled="grid.appScope.folder.isLocked || row.entity.isLocked || rowRenderIndex == 0"\n                                class="btn btn-link btn-sm" uib-tooltip="{{\'label.Remove\' | translate}}">\n                                <i class="fa fa-trash-o"></i>\n                            </button>\n                        </div>'
            }]
        };
    }]);
})();
'use strict';

(function () {
    angular.module('irisApp').controller('DmsFilesUploadCtrl', ["$scope", "$uibModal", "$uibModalInstance", "$translate", "$window", "$timeout", "folder", "FileUploader", "FoldersService", "workflows", "WorkflowService", "folderFiles", "users", "languages", "dmsConfig", "TagsService", "$q", "$filter", function ($scope, $uibModal, $uibModalInstance, $translate, $window, $timeout, folder, FileUploader, FoldersService, workflows, WorkflowService, folderFiles, users, languages, dmsConfig, TagsService, $q, $filter) {
        $scope.folder = folder;
        $scope.folderFiles = folderFiles;
        $scope.languages = languages;
        $scope.workflows = workflows;
        $scope.dmsConfig = dmsConfig;
        $scope.users = users;
        $scope.workflowStates = [];
        $scope.customParameters = {};

        $scope.popover = {
            template: "'" + iris.config.moduleUrl + "/templates/dms.commentPopover.html'"
        };

        $scope.requestWorkflowStates = function (workflowId) {
            $scope.file.workflowStateId = null;
            $scope.workflowStates = [];
            if (!workflowId) return;
            WorkflowService.getWorkflowStates(workflowId).then(function (workflowStates) {
                return $scope.workflowStates = workflowState;
            });
        };

        $scope.commentedItem = null;
        $scope.setCommentedItem = function (file) {
            var f = $scope.uploader.queue.find(function (u) {
                return u.isOpen;
            });
            if (f) f.isOpen = !f.isOpen;
            $scope.commentedItem = file;
        };

        $scope.refreshAllUrls = function () {
            var promises = [];
            $scope.dmsConfig.properties.filter(function (p) {
                return !p.backField && p.value;
            }).forEach(function (p) {
                promises.push(TagsService.saveTag({
                    type: p.name,
                    value: p.value,
                    name: $filter('IrisFilterField')(p.value, [p.directory])
                }));
            });
            $q.all(promises).then(function (tags) {
                var tagsIds = tags.map(function (t) {
                    return t.id;
                });
                $scope.uploader.queue.forEach(function (f) {
                    return $scope.refreshUrl(f, tagsIds);
                });
            });
        };

        $scope.refreshUrl = function (file, tagsIds) {
            $timeout(function () {
                file.url = FoldersService.getUploadUrl(folder);

                if (file.workflowId) {
                    var workflow = $scope.workflows.filter(function (w) {
                        return w.id == file.workflowId;
                    })[0];
                    if (workflow) {
                        var startState = workflow.workflowStates.filter(function (s) {
                            return s.type == 'START';
                        })[0];
                        var startStateId = startState ? startState.id : null;
                        file.url += '?workflowId=' + file.workflowId + (startStateId ? '&workflowStateId=' + startStateId : '');
                    }
                }

                if (file.comment) {
                    file.url += (file.url.indexOf("?") > 0 ? "&" : "?") + ('comment=' + $window.encodeURIComponent(file.comment));
                }

                if (file.ownerId) {
                    file.url += (file.url.indexOf("?") > 0 ? "&" : "?") + ('ownerId=' + file.ownerId);
                }

                if (file.contentLanguage) {
                    file.url += (file.url.indexOf("?") > 0 ? "&" : "?") + ('contentLanguage=' + file.contentLanguage);
                }

                $scope.dmsConfig.properties.filter(function (p) {
                    return !!p.backField && p.value;
                }).forEach(function (p) {
                    file.url += (file.url.indexOf("?") > 0 ? "&" : "?") + (p.backField + '=' + p.value);
                });

                if (tagsIds) {
                    file.url += (file.url.indexOf("?") > 0 ? "&" : "?") + ('tags=' + angular.toJson(tagsIds));
                }
            });
        };

        $scope.checkIfFileExists = function (fileName) {
            var list = $scope.folderFiles;
            for (var i = 0; i < list.length; i++) {
                if (list[i].name == fileName) {
                    return true;
                }
            }
            return false;
        };

        $scope.uploader = new FileUploader({
            url: FoldersService.getUploadUrl(folder),
            headers: {
                'x-iris-access-token': iris.config.accessToken
            },
            onAfterAddingFile: function onAfterAddingFile(item) {
                item.ownerId = iris.config.me.id;
                item.isOpen = false;
                $scope.refreshUrl(item);
            },
            onErrorItem: function onErrorItem(fileItem, response, status, headers) {
                alertify.error($translate.instant('text.dms.FileUploadedError') + ": " + fileItem.file.name);
                $scope.hasErrors = true;
            },
            onCompleteAll: function onCompleteAll() {
                if (!$scope.hasErrors) alertify.success($translate.instant('text.dms.FilesUploadedSuccess'));
                $uibModalInstance.close();
            }
        });
    }]);
})();
'use strict';

(function () {

    angular.module('irisApp').controller('DmsFoldersCtrl', ["$scope", "$uibModal", "$state", "$stateParams", "$translate", "$rootScope", "$q", "$timeout", "projects", "FoldersService", "FilesService", "FileUploader", "UserSettingsService", "DmsActions", "smartFolders", function ($scope, $uibModal, $state, $stateParams, $translate, $rootScope, $q, $timeout, projects, FoldersService, FilesService, FileUploader, UserSettingsService, DmsActions, smartFolders) {

        iris.loader.stop();

        $scope.folders = FoldersService.getFolders();
        $scope.projects = projects;
        $scope.folderUploaders = {};
        $scope.smartFolders = smartFolders;

        function uploadFile(uploader, folder, file) {
            $timeout(function () {
                file.url = FoldersService.getUploadUrl(folder);

                if (file.ownerId) {
                    file.url += (file.url.indexOf("?") > 0 ? "&" : "?") + ('ownerId=' + file.ownerId);
                }

                uploader.uploadAll();
            });
        }

        $scope.getFolderUploader = function (folder) {
            if (!$scope.folderUploaders[folder.id]) {
                $scope.folderUploaders[folder.id] = new FileUploader({
                    url: FoldersService.getUploadUrl(folder),
                    onAfterAddingFile: function onAfterAddingFile(item) {
                        iris.loader.start('.app-body-container');
                        item.ownerId = iris.config.me.id;
                        uploadFile(this, folder, item);
                    },
                    onErrorItem: function onErrorItem(fileItem) {
                        iris.loader.stop();
                        alertify.error($translate.instant('text.dms.FileUploadedError') + ": " + fileItem.file.name);
                        $scope.hasErrors = true;
                    },
                    onCompleteAll: function onCompleteAll() {
                        iris.loader.stop();
                        $scope.$broadcast('dms.folder.modified');
                        if (!$scope.hasErrors) alertify.success($translate.instant('text.dms.FilesUploadedSuccess'));
                    }
                });
            }

            return $scope.folderUploaders[folder.id];
        };

        function updateFolders() {
            FoldersService.requestFolders();
        }
        $scope.$on('dms.folder.content-changed', updateFolders);

        $scope.sidebar.showSystemFolders = false;
        $scope.dmsSystemFolders = function (folder) {
            return folder.isSystem && $scope.sidebar.showSystemFolders || !folder.isSystem;
        };

        $scope.toggleCollapseFolders = function (expanded) {
            FoldersService.toggleCollapseFolders($scope.folders, expanded);
        };

        $scope.toggleFolderCollapsed = function (folder) {
            FoldersService.toggleCollapsed(folder);
        };

        $scope.importZipFolder = function (target_folder_id, format) {
            format = format || 'ZIP';
            if (!target_folder_id) target_folder_id = "root";
            $scope.openImportZip(target_folder_id, format);
        };

        $scope.getExportXlsFolder = function (target_folder_id) {
            return FoldersService.getExportXlsFolder(target_folder_id);
        };

        $scope.openImportZip = function (_targetFolderId, _format) {
            $uibModal.open({
                templateUrl: iris.config.moduleUrl + '/templates/docs.uploadZip.html',
                controller: 'DmsZipUploadCtrl',
                resolve: {
                    'projects': function projects() {
                        return $scope.projects;
                    },
                    'targetFolderId': function targetFolderId() {
                        return _targetFolderId;
                    },
                    'format': function format() {
                        return _format;
                    }
                }
            }).result.then(function () {
                $state.go($state.current, $state.params, { reload: true });
            });
        };

        $scope.setSelectedFolder = function (folder) {
            $scope.sidebar.is_folder_info_shown = !!($scope.sidebar.is_folder_info_shown && $state.params.folder_id && $state.params.folder_id == folder.id ? null : folder);
            if ($scope.filter.text != null) $scope.filter.text = null;
        };

        $scope.removeFolder = function (folder) {
            alertify.confirm($translate.instant('text.dms.FolderRemoveConfirm'), function (e) {
                if (e) {
                    FoldersService.remove(folder).then(function () {
                        alertify.success($translate.instant('text.dms.FolderRemoved'));
                        if ($state.includes('dms.folders.files')) {
                            if ($state.params.folder_id == folder.id || FoldersService.findChildById(folder, $state.params.folder_id) != null) {
                                if (folder.parentId == "/" || folder.parentId == null) {
                                    $scope.breadcrumbs.pathFolders = [];
                                    $state.go('dms.folders');
                                } else {
                                    $state.go('dms.folders.files', { folder_id: folder.parentId });
                                }
                            }
                        }
                    });
                }
            });
        };

        $scope.folderDrop = function (dragData, dropData) {
            var dropFolderId = dropData["folderId"];
            if (!dropFolderId) return;

            var dragFileIds = dragData.getData("getterData");
            dragFileIds && (dragFileIds = dragFileIds.split(","));
            dragFileIds || (dragFileIds = []);

            var dragFileId = dragData.getData("fileId");
            if (dragFileId && dropFolderId) {
                if (dropFolderId == $state.params.folder_id) return;
                dragFileIds = dragFileIds.indexOf(dragFileId) >= 0 ? dragFileIds : [dragFileId];

                iris.loader.start();
                var promises = dragFileIds.map(function (fileId) {
                    return FilesService.moveToFolder(fileId, dropFolderId);
                });
                $q.all(promises).then(function () {
                    alertify.success($translate.instant('label.dms.FilesMoved'));
                    $scope.$broadcast("dms.files.moved");
                    iris.loader.stop();
                });
            }

            var dragFolderId = dragData.getData("folderId");
            if (dragFolderId && dropFolderId && dragFolderId != dropFolderId) {
                iris.loader.start();
                FoldersService.moveToFolder(dragFolderId, dropFolderId).then(function () {
                    alertify.success($translate.instant('text.dms.FolderMoved'));
                    iris.loader.stop();
                });
            }
        };

        $scope.toggleLockedFolder = function (folder) {
            FoldersService.toggleLockedFolder(folder).then(function (folder) {
                $scope.folder = folder;
                alertify.success($translate.instant(folder.isLocked ? 'text.dms.FolderLocked' : 'text.dms.FolderUnlocked'));
                notifyFolderModified(folder.id);
            });
        };

        $scope.getFolderDownloadUrl = function (folder_id) {
            return FoldersService.getFolderDownloadUrl(folder_id);
        };

        function openSelectFolderModal(_folder, label) {
            return $uibModal.open({
                templateUrl: iris.config.moduleUrl + '/templates/dms.files.move.html',
                controller: 'DmsFileMoveCtrl',
                size: 'sm',
                resolve: {
                    'folder': function folder() {
                        return _folder;
                    },
                    'enable_root': function enable_root() {
                        return _folder.parentId != null;
                    },
                    'is_folder_moved': function is_folder_moved() {
                        return true;
                    },
                    'action_label': function action_label() {
                        return label || 'label.Move';
                    }
                }
            }).result;
        }

        $scope.openMoveFolder = function (folder) {
            DmsActions.execute("moveFolder", { folder: folder });
        };

        $scope.openCopyFolder = function (folder) {
            openSelectFolderModal(folder, "label.Copy").then(function (target_folder) {
                iris.loader.start();
                target_folder = target_folder || { id: null };
                FoldersService.copyToFolder(folder.id, target_folder.id).then(function () {
                    alertify.success($translate.instant('text.dms.FolderCopied'));
                    iris.loader.stop();
                });
            });
        };

        $scope.hideSystemFolders = function (folder) {
            if (folder && !folder.isSystem) return true;
            return true;
        };

        $scope.$on('updateSmartFolders', function (event, data) {
            $scope.smartFolders = data;
        });

        $scope.deleteSmartFolder = function (id) {
            alertify.confirm($translate.instant('message.DeleteItemConfirm'), function (e) {
                if (e) {
                    FoldersService.deleteSmartFolder(id).then(function (res) {
                        $scope.smartFolders.splice($scope.smartFolders.findIndex(function (f) {
                            return f.id === id;
                        }), 1);
                        if (id == $stateParams.folderId || $scope.smartFolders.length == 0) $state.go('dms.folders');
                    });
                }
            });
        };
    }]);
})();
'use strict';

(function () {
    angular.module('irisApp').controller('DmsFolderEditCtrl', ["$scope", "$uibModalInstance", "$translate", "$filter", "$q", "folder", "folders", "projects", "dmsConfig", "TagsService", "FoldersService", "flags", "userGroups", "actions", "companies", "FoldersSecurityService", function ($scope, $uibModalInstance, $translate, $filter, $q, folder, folders, projects, dmsConfig, TagsService, FoldersService, flags, userGroups, actions, companies, FoldersSecurityService) {
        $scope.folder = folder;
        $scope.folder.tags = $scope.folder.tags || [];
        $scope.folders = folders;
        $scope.dmsConfig = dmsConfig;
        $scope.dmsConfig.properties = $scope.dmsConfig.properties.filter(function (p) {
            return !p.onlyFile;
        });
        $scope.projects = projects;
        $scope.flags = flags;
        $scope.all_folders = FoldersService.getAllFoldersList();
        $scope.companyTagIndex = $scope.dmsConfig.properties.findIndex(function (obj) {
            return obj.name == "Company";
        });

        $scope.folder.tags.forEach(function (t) {
            var prop = $scope.dmsConfig.properties.find(function (p) {
                return p.name == t.type;
            });
            if (prop) prop.value = t.value;
        });

        $scope.save = function () {
            var promises = [];
            $scope.dmsConfig.properties.forEach(function (p) {
                if (p.value) {
                    promises.push(TagsService.saveTag({
                        type: p.name,
                        value: p.value,
                        name: $filter('IrisFilterField')(p.value, [p.directory])
                    }));
                }
            });
            return $q.all(promises).then(function (res) {
                $scope.folder.tags = res;
                FoldersService.save($scope.folder).then(function (folder) {

                    function setPermission(c, i, folder, action) {
                        if (angular.isUndefined(c)) return Promise.resolve();
                        return FoldersSecurityService.setPermission(folder.id, i, action.alias, c);
                    }

                    var p = Promise.resolve();

                    $scope.actions.forEach(function (action) {
                        if (action.permissions && action.permissions.length > 0) {
                            action.permissions.reduce(function (promise, permission, index) {
                                return p = promise.then(function () {
                                    return setPermission(permission, index, folder, action);
                                });
                            }, p);
                        }
                    });

                    alertify.success($translate.instant('label.dms.FolderSaved'));
                    $uibModalInstance.close(folder);
                });
            });
        };

        $scope.userGroups = userGroups;
        $scope.actions = actions;
        $scope.actions.forEach(function (val) {
            val.permissions = [];
        });
        $scope.companies = companies;
        $scope.params = {
            showPermission: false
        };

        $scope.getUserGroups = function () {
            if ($scope.params.companyId === "all") return $scope.userGroups;
            return $scope.userGroups.filter(function (g) {
                return $scope.params.companyId === "none" && g.companyId == null || g.companyId == $scope.params.companyId;
            });
        };

        $scope.hasFolderPermission = function (usergroup_id, action) {
            if (usergroup_id && action && action.permissions) return action.permissions[usergroup_id];
        };

        $scope.setPermission = function (usergroup_id, action, val) {
            if (usergroup_id && action) {
                if (action.permissions[usergroup_id] && val == null) action.permissions.splice(usergroup_id, 1);
                if (val != null) action.permissions[usergroup_id] = val;
            }
        };
    }]);
})();
'use strict';

(function () {
    angular.module('irisApp').controller('DmsSmartFolderCtrl', ["$scope", "$uibModalInstance", "filter", "UserSettingsService", "smartFolder", "inProgressValues", "filterProjects", "filterWorkflows", "$state", "flags", "FoldersService", function ($scope, $uibModalInstance, filter, UserSettingsService, smartFolder, inProgressValues, filterProjects, filterWorkflows, $state, flags, FoldersService) {

        $scope.inProgressValues = inProgressValues;
        $scope.filterProjects = filterProjects;
        $scope.filterWorkflows = filterWorkflows;
        $scope.flags = flags;

        if (smartFolder) {
            $scope.folder = smartFolder;
            $scope.folder.filter = angular.fromJson($scope.folder.filter);
        } else $scope.folder = { filter: filter };

        $scope.filterWorkflowStates = function () {
            return $scope.folder.filter.workflowId ? $scope.filterWorkflows.filter(function (w) {
                return w.id == $scope.folder.filter.workflowId;
            })[0].workflowStates : [];
        };

        $scope.save = function () {
            $scope.folder.filter = angular.toJson($scope.folder.filter);
            FoldersService.saveSmartFolder($scope.folder).then(function () {
                $uibModalInstance.close();
            });
        };

        $scope.saveAndSearch = function () {
            $scope.folder.filter = angular.toJson($scope.folder.filter);
            FoldersService.saveSmartFolder($scope.folder).then(function (res) {
                $state.go('dms.search', { folderId: res.id, filter: res.filter });
                $uibModalInstance.close();
            });
        };
    }]);
})();
'use strict';

(function () {
    angular.module('irisApp').controller('DmsMainAdvancedSearchCtrl', ["$scope", "$uibModalInstance", "filter", "inProgressValues", "filterProjects", "filterWorkflows", function ($scope, $uibModalInstance, filter, inProgressValues, filterProjects, filterWorkflows) {

        $scope.filter = filter;
        $scope.inProgressValues = inProgressValues;
        $scope.filterProjects = filterProjects;
        $scope.filterWorkflows = filterWorkflows;

        $scope.filterWorkflowStates = function () {
            return $scope.filter.workflowId ? $scope.filterWorkflows.filter(function (w) {
                return w.id == $scope.filter.workflowId;
            })[0].workflowStates : [];
        };

        $scope.advancedSearch = function () {

            if ($scope.filter.date_to) {
                $scope.filter.date_to = new Date(new Date($scope.filter.date_to).setHours(23, 59, 59, 999));
            }

            $uibModalInstance.close($scope.filter);
        };
    }]);
})();
'use strict';

(function () {

    angular.module('irisApp').controller('DmsPluginInstalledCtrl', ["$scope", "$controller", "$timeout", "DmsAppService", "$uibModal", function ($scope, $controller, $timeout, DmsAppService, $uibModal) {
        var ctrl = this;
        angular.extend($scope, $controller('WebSocketMixin', { $scope: $scope }));
        var currentUserId = iris.config.me.id;
        var neverShowPluginTooltipKey = 'neverShowPluginTooltip-' + currentUserId;
        ctrl.neverShowPlugin = localStorage.getItem(neverShowPluginTooltipKey) == 'true' ? true : false;
        ctrl.showDownloadTooltip = true;
        ctrl.showChoiceTooltip = ctrl.showDownloadTooltip;
        ctrl.neverShowAgain = false;
        ctrl.isPluginInstalled = false;

        $scope.webSocket.connect('/websocket');

        DmsAppService.getAllBundles().then(function (bundles) {
            if (bundles instanceof Array && bundles.length > 0) {
                ctrl.bundle = bundles[0];
                ctrl.downloadPluginUrl = DmsAppService.getBundleUrl(bundles[0].bundleName);
            }
        });

        DmsAppService.getIP().then(function (localIp) {
            DmsAppService.checkAppState(localIp).then(function (state) {
                ctrl.isPluginInstalled = state.isInstalled;
            });
        });

        ctrl.openInfoModal = function () {
            $uibModal.open({
                templateUrl: iris.config.moduleUrl + "/templates/dms.install-info.modal.html",
                controller: 'DmsPluginInstalledInfoModalCtrl',
                resolve: {
                    'bundle': function bundle() {
                        return ctrl.bundle;
                    }
                }
            });
        };

        ctrl.onCloseChoice = function () {
            ctrl.showChoiceTooltip = !ctrl.showChoiceTooltip;
            localStorage.setItem(neverShowPluginTooltipKey, ctrl.neverShowAgain);
        };

        $scope.$watch('ctrl.showDownloadTooltip', function (newValue) {
            if (newValue !== undefined) {
                ctrl.showChoiceTooltip = !newValue;
            }
        }, true);

        $scope.$on('$destroy', function () {
            if ($scope.webSocket) {
                $scope.webSocket.unsubscribe('/user-broker/' + iris.config.me.id + '/dms/app-subscribe/' + localIp);
            }
        });
    }]);

    angular.module('irisApp').controller('DmsPluginInstalledInfoModalCtrl', ["$scope", "$uibModalInstance", "bundle", "DmsAppService", function ($scope, $uibModalInstance, bundle, DmsAppService) {
        $scope.bundle = bundle;
        $scope.bundleUrl = DmsAppService.getBundleUrl(bundle.bundleName);
    }]);
})();
'use strict';

(function () {
    angular.module('irisApp').controller('DmsCtrl', ["$scope", "$state", "$translate", "$controller", "folders", "dmsConfig", "filterProjects", "trashFolder", "filterWorkflows", "SecurityService", "projects", "FoldersService", "$uibModal", "defaultActionsList", "filesGridIsTrashDefaultColDefs", "dmsGridConfig", "dmsGridDefaultColDefs", function ($scope, $state, $translate, $controller, folders, dmsConfig, _filterProjects, trashFolder, _filterWorkflows, SecurityService, projects, FoldersService, $uibModal, defaultActionsList, filesGridIsTrashDefaultColDefs, _dmsGridConfig, dmsGridDefaultColDefs) {
        angular.extend($scope, $controller('SecurityMixin', { $scope: $scope }));
        iris.loader.start('.module-content');
        $scope.dmsConfig = dmsConfig;
        $scope.projects = projects;
        $scope.folders = folders;
        $scope.trashFolder = trashFolder;

        $scope.dmsGridConfig = _dmsGridConfig;
        $scope.defaultActionsList = defaultActionsList;
        $scope.filesGridIsTrashDefaultColDefs = filesGridIsTrashDefaultColDefs;
        $scope.dmsGridDefaultColDefs = dmsGridDefaultColDefs;

        ($scope.initBreadcrumbs = function () {
            $scope.breadcrumbs = {
                pathFolders: []
            };
        })();

        $scope.foldersFilter = {
            project: null
        };

        $scope.backToFolders = function () {
            $scope.breadcrumbs.pathFolders = [];
            //$state.go('dms.folders');
        };

        var notifyFolderModified = function notifyFolderModified(folder_id) {
            $scope.$broadcast('dms.folder.modified');
        };

        $scope.addFolder = function (target_folder_id) {
            if (angular.isUndefined(target_folder_id)) target_folder_id = null;

            if (!target_folder_id && !$scope.hasPermission('DMS', 'config', 'Module')) return;

            $scope.openEditFolder({ parentId: target_folder_id });
        };

        $scope.openEditFolder = function (folder) {
            $scope.folder = FoldersService.createFolder(folder);

            $uibModal.open({
                templateUrl: iris.config.moduleUrl + '/templates/dms.folders.edit.html',
                controller: 'DmsFolderEditCtrl',
                resolve: {
                    'folder': function folder() {
                        return angular.copy($scope.folder);
                    },
                    'folders': function folders() {
                        return $scope.folders;
                    },
                    'projects': function projects() {
                        return $scope.projects;
                    },
                    'dmsConfig': function dmsConfig() {
                        return angular.copy($scope.dmsConfig);
                    },
                    'flags': function flags(FoldersService) {
                        return FoldersService.getFolderFlagIcons();
                    },
                    'userGroups': function userGroups(UserGroupsService) {
                        return UserGroupsService.getUserGroups().$promise.then();
                    },
                    'actions': function actions(FoldersSecurityService) {
                        return FoldersSecurityService.getDMSSecurityActions();
                    },
                    'companies': function companies(CompaniesService) {
                        return CompaniesService.getCompanies().$promise.then(function (companies) {
                            companies.push({ id: "all", name: $translate.instant('label.dms.AllUserGroups') });
                            companies.push({ id: "none", name: $translate.instant('label.dms.WithoutCompany') });
                            return companies;
                        });
                    }
                }
            }).result.then(function (folder) {
                $scope.folders = FoldersService.getFolders();
                $scope.updateRights(['iris:repoContentFolder', 'Module']);
                notifyFolderModified(folder.id);
            });
        };

        $scope.checkFilter = function () {
            if (!$scope.filter.workflowId) $scope.filter.workflowStateId = null;
        };

        $scope.clearFilter = function () {
            $scope.filter = {
                is_advanced: false,
                text: null,
                is_text_comments: true,
                is_text_created_by: true,
                is_text_name: true,
                is_text_content: false,
                date_from: null,
                date_to: null,
                inProgress: null,
                projectId: null,
                workflowId: null,
                workflowStateId: null
            };
        };
        $scope.clearFilter();

        if ($state.is('dms.search')) angular.extend($scope.filter, angular.fromJson($state.params.filter));

        $scope.search = function () {
            $state.go('dms.search', { filter: angular.toJson($scope.filter), folderId: null });
        };

        $scope.sidebar = {
            is_folder_info_shown: false,
            is_file_info_shown: false
        };

        $scope.folderTabs = {
            activeTab: 'Details'
        };

        $scope.hasPermission = function (folder_id, action, subject_name) {
            subject_name = subject_name || 'iris:repoContentFolder';
            return SecurityService.hasPermissions(folder_id, subject_name, action);
        };

        $scope.isParentFolderExpanded = function (parent_folder, child_folder_id) {
            if (parent_folder.id === child_folder_id) return true;
            var pIds = FoldersService.getParentsIds(FoldersService.getByIdInList(child_folder_id));
            return pIds.indexOf(parent_folder.id) !== -1 && !parent_folder.expanded;
        };

        $scope.openSmartFolderModal = function (_filter, _smartFolder) {
            $uibModal.open({
                templateUrl: iris.config.moduleUrl + '/templates/dms.folders.smart-folder.html',
                controller: 'DmsSmartFolderCtrl',
                resolve: {
                    'filter': function filter() {
                        return _filter;
                    },
                    'smartFolder': function smartFolder() {
                        return angular.copy(_smartFolder) || null;
                    },
                    'inProgressValues': function inProgressValues() {
                        return [{ id: "true", name: $translate.instant('label.dms.FileInProgress') }, { id: "false", name: $translate.instant('label.dms.FileAvailable') }];
                    },
                    'filterProjects': function filterProjects() {
                        return _filterProjects;
                    },
                    'filterWorkflows': function filterWorkflows() {
                        return _filterWorkflows;
                    },
                    'flags': function flags() {
                        return FoldersService.getFolderFlagIcons();
                    }
                }
            }).result.then(function () {
                FoldersService.getSmartFolders().then(function (res) {
                    $scope.$broadcast('updateSmartFolders', res);
                });
            });
        };

        $scope.openAdvancedSearchModal = function () {
            $uibModal.open({
                templateUrl: iris.config.moduleUrl + '/templates/dms.main.advanced-search.html',
                controller: 'DmsMainAdvancedSearchCtrl',
                resolve: {
                    filter: function filter() {
                        return $scope.filter;
                    },
                    inProgressValues: function inProgressValues() {
                        return [{ id: "true", name: $translate.instant('label.dms.FileInProgress') }, { id: "false", name: $translate.instant('label.dms.FileAvailable') }];
                    },
                    filterProjects: function filterProjects() {
                        return _filterProjects;
                    },
                    filterWorkflows: function filterWorkflows() {
                        return _filterWorkflows;
                    }

                }
            }).result.then(function (filter) {
                $scope.filter = filter;
                $scope.search();
            });
        };

        $scope.setBreadcrumbsType = function (index) {
            if ($scope.breadcrumbs.pathFolders.length < 6 || $scope.breadcrumbs.pathFolders.length > 5 && (index == 0 || index == 1 || index == $scope.breadcrumbs.pathFolders.length - 1 || index == $scope.breadcrumbs.pathFolders.length - 2)) return true;
            return false;
        };

        $scope.openChangeGridView = function () {
            $uibModal.open({
                templateUrl: iris.config.moduleUrl + '/templates/dms.files.change-grid-view.html',
                size: 'sm',
                resolve: {
                    dmsGridConfig: function dmsGridConfig() {
                        return angular.copy(_dmsGridConfig);
                    }
                },
                controller: 'DMSFilesChangeGridViewCtrl'
            }).result.then(function (settings) {
                iris.loader.start('.app-body');
                $scope.dmsGridConfig = _dmsGridConfig = settings;
                $scope.$broadcast('updateFilesGrid');
                iris.loader.stop('.app-body');
            });
        };

        $scope.$on('selectFolder', function (args) {
            $scope.folder = angular.copy(args.targetScope.folder);
        });

        $scope.openUploaderForm = function () {
            $scope.$broadcast('openUploaderForm');
        };

        $scope.$on('selectFileInGrid', function (args) {
            $scope.files = angular.copy(args.targetScope.files);
        });

        $scope.openMoveFiles = function () {
            $scope.$broadcast('openMoveFiles');
        };

        $scope.openCopyFiles = function () {
            $scope.$broadcast('openCopyFiles');
        };

        $scope.openSendMessageModal = function () {
            $scope.$broadcast('openSendMessageModal');
        };

        $scope.getSelectedFilesDownloadUrl = function () {
            $scope.$broadcast('getSelectedFilesDownloadUrl');
        };

        $scope.removeSelectedFiles = function () {
            $scope.$broadcast('removeSelectedFiles');
        };
    }]);
})();
'use strict';

(function () {
    angular.module('irisApp').controller('DmsSearchCtrl', ["$scope", "$state", "$translate", "$controller", "files", "FoldersService", "FilesService", "folders", "smartFolders", function ($scope, $state, $translate, $controller, files, FoldersService, FilesService, folders, smartFolders) {
        angular.extend($scope, $controller('DmsFilesBaseCtrl', { $scope: $scope, workflowsFull: [] }));
        angular.extend($scope, $controller('DmsFoldersCtrl', { $scope: $scope, projects: [], smartFolders: smartFolders }));

        iris.loader.stop();

        $scope.files = files;
        $scope.folders = folders;
        $scope.smartFolders = smartFolders;

        $scope.getPathToFile = function (folder_id) {
            var folder = FoldersService.getByIdInList(folder_id);
            if (!folder) return null;

            return folder.path;
        };

        $scope.gridOptions = {
            data: 'files',
            expandableRowTemplate: iris.config.moduleUrl + '/templates/dms.search.expandable-template.html',
            expandableRowHeight: 70,
            //subGridVariable will be available in subGrid scope
            enableFullRowSelection: false,
            enableSelectAll: true,
            selectionRowHeaderWidth: 35,
            multiSelect: true,
            columnDefs: [{
                field: 'name',
                width: '**',
                displayName: $translate.instant('label.Name'),
                enableSorting: true,
                cellTemplate: '\n                        <div class="ui-grid-cell-contents actions">\n                            <a href="javascript:void(0)" uib-tooltip="{{row.entity.name}}"\n                               ng-click="grid.appScope.setSelectedFile(row.entity)">\n                                <i class="fa {{::grid.appScope.getFileIcon(row.entity.mimeType)}}"></i>\n                                {{row.entity.name}}\n                            </a>\n                        </div>'
            }, {
                name: 'actions',
                displayName: $translate.instant('label.Actions'),
                width: 230,
                enableSorting: false,
                cellTemplate: '\n                        <div class="ui-grid-cell-contents actions">\n                            <a ng-href="{{grid.appScope.getFileDownloadUrl(row.entity.id)}}"\n                               class="btn btn-link"\n                               uib-tooltip="{{\'label.Download\' | translate}}">\n                                <i class="fa fa-download"></i>\n                            </a>\n                            <button ng-click="grid.appScope.goTo(\'dms.folders.files\',{folder_id:row.entity.parentId, file: row.entity.id})"\n                                    class="btn btn-link"\n                                    uib-tooltip="{{\'label.dms.GoToFolder\' | translate}}">\n                                <i class="fa fa-sign-in"></i>\n                            </button>\n                        </div>'
            }, {
                field: 'parentId',
                width: '**',
                displayName: $translate.instant('label.Path'),
                enableSorting: false,
                cellTemplate: '\n                        <div class="ui-grid-cell-contents actions">\n                            <a href="javascript:void(0)" ng-click="grid.appScope.goTo(\'dms.folders.files\',{folder_id:row.entity.parentId, file: row.entity.id})" class="btn btn-link" uib-tooltip="{{\'label.dms.GoToFolder\' | translate}}">\n                                {{::grid.appScope.getPathToFile(row.entity.parentId)}}\n                            </a> \n                        </div>'
            }, {
                field: 'updatedOn',
                width: 150,
                displayName: $translate.instant('label.UpdatedOn'),
                enableSorting: true,
                cellFilter: 'date:\'dd.MM.yyyy HH:mm:ss\''
            }, {
                field: 'createdBy',
                width: '*',
                displayName: $translate.instant('label.CreatedBy'),
                enableSorting: true
            }, {
                field: 'size',
                width: '*',
                displayName: $translate.instant('label.Size'),
                enableSorting: true,
                cellFilter: 'filesize'
            }],
            // rowTemplate: "<div ng-repeat=\"(colRenderIndex, col) in colContainer.renderedColumns track by col.colDef.name\" class=\"ui-grid-cell\" \
            // ng-class=\"{ 'ui-grid-row-header-cell': col.isRowHeader, 'row-selected':row.entity.id == grid.appScope.selected_file.id}\" ui-grid-cell ></div>",
            onRegisterApi: function onRegisterApi(gridApi) {
                $scope.gridOptions.gridAPI = gridApi;

                gridApi.selection.on.rowSelectionChanged($scope, function (row, event) {
                    $scope.selectFile(row.entity);
                });

                gridApi.selection.on.rowSelectionChangedBatch($scope, function (rows) {
                    for (var i in rows) {
                        $scope.selectFile(rows[i].entity);
                    }
                });

                gridApi.core.on.rowsRendered($scope, function () {
                    if (!gridApi.grid.expandable.expandedAll) {
                        gridApi.expandable.expandAllRows();
                    }
                });
            }
        };

        $scope.removeFile = function (file) {
            alertify.confirm($translate.instant('text.dms.FileRemoveConfirm'), function (e) {
                if (e) {
                    FilesService.remove(file.id).then(function () {
                        alertify.success($translate.instant('text.FileRemoved'));
                        for (var i = 0, c = $scope.files.length; i < c; i++) {
                            if ($scope.files[i].id == file.id) {
                                $scope.files.splice(i, 1);
                                break;
                            }
                        }
                    });
                }
            });
        };

        $scope.goTo = function (state, state_params) {
            state_params = state_params || {};
            $scope.clearFilter();
            $state.go(state, state_params);
        };
    }]);
})();
"use strict";

angular.module('irisApp').config(["$stateProvider", "$urlRouterProvider", function ($stateProvider, $urlRouterProvider) {
    $urlRouterProvider.when('', '/folders').when('#', '/folders').when('/', '/folders');
    $stateProvider.state('dms', {
        url: "",
        abastract: true,
        templateUrl: iris.config.moduleUrl + '/templates/dms.main.html',
        controller: 'DmsCtrl',
        resolve: {
            'folders': ["FoldersService", function (FoldersService) {
                return FoldersService.requestFolders().$promise.then(function (data) {
                    return data;
                });
            }],
            'trashFolder': ["folders", function (folders) {
                var dmsFolder = folders.find(function (f) {
                    return f.name == 'DMS';
                });
                if (!dmsFolder || !dmsFolder.children) return null;

                return dmsFolder.children.find(function (f) {
                    return f.isTrashBin;
                });
            }],
            'filterProjects': ["ProjectsService", function (ProjectsService) {
                return ProjectsService.getPreloadedProjects();
            }],
            'filterWorkflows': ["WorkflowService", function (WorkflowService) {
                return WorkflowService.getAllWorkflowsByType('DOCUMENT');
            }],
            'countries': function countries(CountriesService) {
                return CountriesService.query();
            },
            'dmsConfig': function dmsConfig(DmsPropertiesService) {
                return DmsPropertiesService.getDmsConfig();
            },
            'projects': ["ProjectsService", function (ProjectsService) {
                return ProjectsService.getPreloadedProjects();
            }],
            'defaultActionsList': function defaultActionsList(DmsGridConfigurationService) {
                return DmsGridConfigurationService.getDefaultActionsList();
            },
            'filesGridIsTrashDefaultColDefs': function filesGridIsTrashDefaultColDefs(DmsGridConfigurationService) {
                return DmsGridConfigurationService.getFilesGridIsTrashDefaultColDefs();
            },
            'dmsGridConfig': function dmsGridConfig(UserSettingsService, DmsGridConfigurationService) {
                return UserSettingsService.getUserSettingsById('dms-grid-config-vmodal5', iris.config.me.id);
            },
            'dmsGridDefaultColDefs': function dmsGridDefaultColDefs($filter, DmsGridConfigurationService, dmsGridConfig) {
                return DmsGridConfigurationService.applyColumnsSettings(dmsGridConfig);
            }
        }
    }).state('dms.folders', { //List of folders
        url: "/folders",
        templateUrl: iris.config.moduleUrl + '/templates/dms.folders.html',
        controller: 'DmsFoldersCtrl',
        resolve: {
            'projects': function projects(ProjectsService) {
                return ProjectsService.getPreloadedProjects();
            },
            'smartFolders': function smartFolders(FoldersService) {
                return FoldersService.getSmartFolders().then(function (res) {
                    return res;
                });
            }
        }
    }).state('dms.folders.files', { //List of files
        url: "/:folder_id/files?file&tab&isSmartFolder",
        templateUrl: iris.config.moduleUrl + '/templates/dms.files.html',
        controller: 'DmsFilesCtrl',
        resolve: {
            'folder': function folder(FoldersService, $stateParams) {
                return FoldersService.getById($stateParams.folder_id).$promise.then(function (res) {
                    return res;
                });
            },
            'files': function files(FilesService, $stateParams, folder) {
                return FilesService.getFolderFiles(folder.id).then(function (res) {
                    return res;
                });
            },
            'projects': ["ProjectsService", function (ProjectsService) {
                return ProjectsService.getPreloadedProjects();
            }],
            'workflows': ["WorkflowService", "folder", function (WorkflowService, folder) {
                return folder.projectId ? WorkflowService.getWorkflowsByType(folder.projectId, 'DOCUMENT') : [];
            }],
            'localIp': ["DmsAppService", function (DmsAppService) {
                return DmsAppService.getIP();
            }]
        }
    }).state('dms.print-file-comments', {
        url: "/files/:file_id/comments-print",
        templateUrl: iris.config.moduleUrl + '/templates/dms.comments-print.html',
        controller: 'DmsCommentsPrintCtrl',
        resolve: {
            'entity': function entity($stateParams, FilesService) {
                return FilesService.getFileById($stateParams.file_id);
            },
            'isFile': function isFile() {
                return true;
            },
            'comments': function comments($stateParams, CommentsService) {
                return CommentsService.getList({ moduleName: 'dms', entityName: 'files', entityId: $stateParams.file_id });
            }
        }
    }).state('dms.print-folder-comments', {
        url: "/folders/:folder_id/comments-print",
        templateUrl: iris.config.moduleUrl + '/templates/dms.comments-print.html',
        controller: 'DmsCommentsPrintCtrl',
        resolve: {
            'entity': function entity($stateParams, FoldersService) {
                return FoldersService.getById($stateParams.folder_id);
            },
            'isFile': function isFile() {
                return false;
            },
            'comments': function comments($stateParams, CommentsService) {
                return CommentsService.getList({ moduleName: 'dms', entityName: 'folders', entityId: $stateParams.folder_id });
            }
        }
    }).state('dms.folders.trash', { //List of files
        url: "/:folder_id/trash/files?file",
        templateUrl: iris.config.moduleUrl + '/templates/dms.trash.html',
        controller: 'DmsFilesCtrl',
        resolve: {
            'files': ["FilesService", "$stateParams", function (FilesService, $stateParams) {
                return FilesService.getFolderFiles($stateParams.folder_id).then(function (value) {
                    return value;
                });
            }],
            'folder': ["FoldersService", "$stateParams", function (FoldersService, $stateParams) {
                return FoldersService.getById($stateParams.folder_id).$promise.then(function (data) {
                    return data;
                });
            }],
            'projects': ["ProjectsService", function (ProjectsService) {
                return ProjectsService.getPreloadedProjects();
            }],
            'workflows': ["WorkflowService", "folder", function (WorkflowService, folder) {
                return folder.projectId ? WorkflowService.getWorkflowsByType(folder.projectId, 'DOCUMENT') : [];
            }],
            'localIp': ["DmsAppService", function (DmsAppService) {
                return DmsAppService.getIP();
            }]
        }
    }).state('dms.search', { //Search results = list of resulted files
        url: "/search?filter&folderId",
        templateUrl: iris.config.moduleUrl + '/templates/dms.search.html',
        controller: 'DmsSearchCtrl',
        resolve: {
            'folders': function folders(FoldersService) {
                return FoldersService.requestFolders().$promise.then(function (res) {
                    return res;
                });
            },
            'files': function files(FilesService, $stateParams) {
                return FilesService.searchFiles(FilesService.prepareSearchFilter($stateParams.filter)).then(function (res) {
                    return res;
                });
            },
            'smartFolders': function smartFolders(FoldersService) {
                return FoldersService.getSmartFolders().then(function (res) {
                    return res;
                });
            }
        }
    }).state('contacts', {
        url: "/contacts",
        templateUrl: iris.config.moduleUrl + '/templates/dms.contacts.html',
        controller: 'DmsContactsCtrl',
        resolve: {
            contacts: function contacts(ContactsService) {
                return ContactsService.requestContacts();
            },
            companies: function companies(CompaniesService) {
                return CompaniesService.getCompanies().$promise;
            }
        }
    }).state('contacts.add', {
        url: "/add",
        controller: 'DmsContactsEditCtrl',
        resolve: {
            contacts: function contacts(ContactsService) {
                return ContactsService.requestContacts();
            }
        }
    }).state('contacts.edit', {
        url: "/:id/edit",
        controller: 'DmsContactsEditCtrl',
        resolve: {
            contacts: function contacts(ContactsService) {
                return ContactsService.requestContacts();
            }
        }
    });
}]);
'use strict';

(function () {
    irisAppDependencies.add("dms");

    angular.module('dms', []).directive('dmsTooltip', function () {
        return {
            restrict: 'A',
            link: function link(scope, element, attrs) {

                scope.$watch(attrs.ngModel, function () {

                    attrs.tooltipEnable = "false";

                    var e = element[0].querySelector('.selectize-input');

                    // scrollWidth|Height - get the entire width|height of an element, including padding
                    // offsetWidth|Height - get the viewable width|height of a element, including padding and border
                    if (e && e.scrollWidth > e.offsetWidth || e.scrollHeight > e.offsetHeight) {
                        attrs.tooltipEnable = "true";
                    }
                });
            }
        };
    });
})();
'use strict';

/**
 * @license Angular UI Tree v2.15.0
 * (c) 2010-2016. https://github.com/angular-ui-tree/angular-ui-tree
 * License: MIT
 */
(function () {
    'use strict';

    angular.module('ui.tree', []).constant('treeConfig', {
        treeClass: 'angular-ui-tree',
        emptyTreeClass: 'angular-ui-tree-empty',
        hiddenClass: 'angular-ui-tree-hidden',
        nodesClass: 'angular-ui-tree-nodes',
        nodeClass: 'angular-ui-tree-node',
        handleClass: 'angular-ui-tree-handle',
        placeholderClass: 'angular-ui-tree-placeholder',
        dragClass: 'angular-ui-tree-drag',
        dragThreshold: 3,
        levelThreshold: 30,
        defaultCollapsed: false
    });
})();

(function () {
    'use strict';

    angular.module('ui.tree').controller('TreeHandleController', ['$scope', '$element', function ($scope, $element) {
        this.scope = $scope;

        $scope.$element = $element;
        $scope.$nodeScope = null;
        $scope.$type = 'uiTreeHandle';
    }]);
})();

(function () {
    'use strict';

    angular.module('ui.tree').controller('TreeNodeController', ['$scope', '$element', function ($scope, $element) {
        this.scope = $scope;

        $scope.$element = $element;
        $scope.$modelValue = null; // Model value for node;
        $scope.$parentNodeScope = null; // uiTreeNode Scope of parent node;
        $scope.$childNodesScope = null; // uiTreeNodes Scope of child nodes.
        $scope.$parentNodesScope = null; // uiTreeNodes Scope of parent nodes.
        $scope.$treeScope = null; // uiTree scope
        $scope.$handleScope = null; // it's handle scope
        $scope.$type = 'uiTreeNode';
        $scope.$$allowNodeDrop = false;
        $scope.collapsed = false;

        $scope.init = function (controllersArr) {
            var treeNodesCtrl = controllersArr[0];
            $scope.$treeScope = controllersArr[1] ? controllersArr[1].scope : null;

            // find the scope of it's parent node
            $scope.$parentNodeScope = treeNodesCtrl.scope.$nodeScope;
            // modelValue for current node
            $scope.$modelValue = treeNodesCtrl.scope.$modelValue[$scope.$index];
            $scope.$parentNodesScope = treeNodesCtrl.scope;
            treeNodesCtrl.scope.initSubNode($scope); // init sub nodes

            $element.on('$destroy', function () {
                treeNodesCtrl.scope.destroySubNode($scope); // destroy sub nodes
            });
        };

        $scope.index = function () {
            return $scope.$parentNodesScope.$modelValue.indexOf($scope.$modelValue);
        };

        $scope.dragEnabled = function () {
            return !($scope.$treeScope && !$scope.$treeScope.dragEnabled);
        };

        $scope.isSibling = function (targetNode) {
            return $scope.$parentNodesScope == targetNode.$parentNodesScope;
        };

        $scope.isChild = function (targetNode) {
            var nodes = $scope.childNodes();
            return nodes && nodes.indexOf(targetNode) > -1;
        };

        $scope.prev = function () {
            var index = $scope.index();
            if (index > 0) {
                return $scope.siblings()[index - 1];
            }
            return null;
        };

        $scope.siblings = function () {
            return $scope.$parentNodesScope.childNodes();
        };

        $scope.childNodesCount = function () {
            return $scope.childNodes() ? $scope.childNodes().length : 0;
        };

        $scope.hasChild = function () {
            return $scope.childNodesCount() > 0;
        };

        $scope.childNodes = function () {
            return $scope.$childNodesScope && $scope.$childNodesScope.$modelValue ? $scope.$childNodesScope.childNodes() : null;
        };

        $scope.accept = function (sourceNode, destIndex) {
            return $scope.$childNodesScope && $scope.$childNodesScope.$modelValue && $scope.$childNodesScope.accept(sourceNode, destIndex);
        };

        $scope.remove = function () {
            return $scope.$parentNodesScope.removeNode($scope);
        };

        $scope.toggle = function () {
            $scope.collapsed = !$scope.collapsed;
        };

        $scope.collapse = function () {
            $scope.collapsed = true;
        };

        $scope.expand = function () {
            $scope.collapsed = false;
        };

        $scope.depth = function () {
            var parentNode = $scope.$parentNodeScope;
            if (parentNode) {
                return parentNode.depth() + 1;
            }
            return 1;
        };

        /**
         * Returns the depth of the deepest subtree under this node
         * @param scope a TreeNodesController scope object
         * @returns Depth of all nodes *beneath* this node. If scope belongs to a leaf node, the
         *   result is 0 (it has no subtree).
         */
        function countSubTreeDepth(scope) {
            var thisLevelDepth = 0,
                childNodes = scope.childNodes(),
                childNode,
                childDepth,
                i;
            if (!childNodes || childNodes.length === 0) {
                return 0;
            }
            for (i = childNodes.length - 1; i >= 0; i--) {
                childNode = childNodes[i], childDepth = 1 + countSubTreeDepth(childNode);
                thisLevelDepth = Math.max(thisLevelDepth, childDepth);
            }
            return thisLevelDepth;
        }

        $scope.maxSubDepth = function () {
            return $scope.$childNodesScope ? countSubTreeDepth($scope.$childNodesScope) : 0;
        };
    }]);
})();

(function () {
    'use strict';

    angular.module('ui.tree').controller('TreeNodesController', ['$scope', '$element', function ($scope, $element) {
        this.scope = $scope;

        $scope.$element = $element;
        $scope.$modelValue = null;
        $scope.$nodeScope = null; // the scope of node which the nodes belongs to
        $scope.$treeScope = null;
        $scope.$type = 'uiTreeNodes';
        $scope.$nodesMap = {};

        $scope.nodropEnabled = false;
        $scope.maxDepth = 0;
        $scope.cloneEnabled = false;

        $scope.initSubNode = function (subNode) {
            if (!subNode.$modelValue) {
                return null;
            }
            $scope.$nodesMap[subNode.$modelValue.$$hashKey] = subNode;
        };

        $scope.destroySubNode = function (subNode) {
            if (!subNode.$modelValue) {
                return null;
            }
            $scope.$nodesMap[subNode.$modelValue.$$hashKey] = null;
        };

        $scope.accept = function (sourceNode, destIndex) {
            return $scope.$treeScope.$callbacks.accept(sourceNode, $scope, destIndex);
        };

        $scope.beforeDrag = function (sourceNode) {
            return $scope.$treeScope.$callbacks.beforeDrag(sourceNode);
        };

        $scope.isParent = function (node) {
            return node.$parentNodesScope == $scope;
        };

        $scope.hasChild = function () {
            return $scope.$modelValue.length > 0;
        };

        $scope.safeApply = function (fn) {
            var phase = this.$root.$$phase;
            if (phase == '$apply' || phase == '$digest') {
                if (fn && typeof fn === 'function') {
                    fn();
                }
            } else {
                this.$apply(fn);
            }
        };

        $scope.removeNode = function (node) {
            var index = $scope.$modelValue.indexOf(node.$modelValue);
            if (index > -1) {
                $scope.safeApply(function () {
                    $scope.$modelValue.splice(index, 1)[0];
                });
                return $scope.$treeScope.$callbacks.removed(node);
            }
            return null;
        };

        $scope.insertNode = function (index, nodeData) {
            $scope.safeApply(function () {
                $scope.$modelValue.splice(index, 0, nodeData);
            });
        };

        $scope.childNodes = function () {
            var i,
                nodes = [];
            if ($scope.$modelValue) {
                for (i = 0; i < $scope.$modelValue.length; i++) {
                    nodes.push($scope.$nodesMap[$scope.$modelValue[i].$$hashKey]);
                }
            }
            return nodes;
        };

        $scope.depth = function () {
            if ($scope.$nodeScope) {
                return $scope.$nodeScope.depth();
            }
            return 0; // if it has no $nodeScope, it's root
        };

        // check if depth limit has reached
        $scope.outOfDepth = function (sourceNode) {
            var maxDepth = $scope.maxDepth || $scope.$treeScope.maxDepth;
            if (maxDepth > 0) {
                return $scope.depth() + sourceNode.maxSubDepth() + 1 > maxDepth;
            }
            return false;
        };
    }]);
})();

(function () {
    'use strict';

    angular.module('ui.tree').controller('TreeController', ['$scope', '$element', function ($scope, $element) {
        this.scope = $scope;

        $scope.$element = $element;
        $scope.$nodesScope = null; // root nodes
        $scope.$type = 'uiTree';
        $scope.$emptyElm = null;
        $scope.$callbacks = null;

        $scope.dragEnabled = true;
        $scope.emptyPlaceholderEnabled = true;
        $scope.maxDepth = 0;
        $scope.dragDelay = 0;
        $scope.cloneEnabled = false;
        $scope.nodropEnabled = false;

        // Check if it's a empty tree
        $scope.isEmpty = function () {
            return $scope.$nodesScope && $scope.$nodesScope.$modelValue && $scope.$nodesScope.$modelValue.length === 0;
        };

        // add placeholder to empty tree
        $scope.place = function (placeElm) {
            $scope.$nodesScope.$element.append(placeElm);
            $scope.$emptyElm.remove();
        };

        this.resetEmptyElement = function () {
            if ((!$scope.$nodesScope.$modelValue || $scope.$nodesScope.$modelValue.length === 0) && $scope.emptyPlaceholderEnabled) {
                $element.append($scope.$emptyElm);
            } else {
                $scope.$emptyElm.remove();
            }
        };

        $scope.resetEmptyElement = this.resetEmptyElement;
    }]);
})();

(function () {
    'use strict';

    angular.module('ui.tree').directive('uiTree', ['treeConfig', '$window', function (treeConfig, $window) {
        return {
            restrict: 'A',
            scope: true,
            controller: 'TreeController',
            link: function link(scope, element, attrs, ctrl) {
                var callbacks = {
                    accept: null,
                    beforeDrag: null
                },
                    config = {},
                    tdElm,
                    $trElm,
                    emptyElmColspan;

                angular.extend(config, treeConfig);
                if (config.treeClass) {
                    element.addClass(config.treeClass);
                }

                if (element.prop('tagName').toLowerCase() === 'table') {
                    scope.$emptyElm = angular.element($window.document.createElement('tr'));
                    $trElm = element.find('tr');
                    // If we can find a tr, then we can use its td children as the empty element colspan.
                    if ($trElm.length > 0) {
                        emptyElmColspan = angular.element($trElm).children().length;
                    } else {
                        // If not, by setting a huge colspan we make sure it takes full width.
                        emptyElmColspan = 1000000;
                    }
                    tdElm = angular.element($window.document.createElement('td')).attr('colspan', emptyElmColspan);
                    scope.$emptyElm.append(tdElm);
                } else {
                    scope.$emptyElm = angular.element($window.document.createElement('div'));
                }

                if (config.emptyTreeClass) {
                    scope.$emptyElm.addClass(config.emptyTreeClass);
                }

                scope.$watch('$nodesScope.$modelValue.length', function (val) {
                    if (!angular.isNumber(val)) {
                        return;
                    }

                    ctrl.resetEmptyElement();
                }, true);

                scope.$watch(attrs.dragEnabled, function (val) {
                    if (typeof val == 'boolean') {
                        scope.dragEnabled = val;
                    }
                });

                scope.$watch(attrs.emptyPlaceholderEnabled, function (val) {
                    if (typeof val == 'boolean') {
                        scope.emptyPlaceholderEnabled = val;
                        ctrl.resetEmptyElement();
                    }
                });

                scope.$watch(attrs.nodropEnabled, function (val) {
                    if (typeof val == 'boolean') {
                        scope.nodropEnabled = val;
                    }
                });

                scope.$watch(attrs.cloneEnabled, function (val) {
                    if (typeof val == 'boolean') {
                        scope.cloneEnabled = val;
                    }
                });

                scope.$watch(attrs.maxDepth, function (val) {
                    if (typeof val == 'number') {
                        scope.maxDepth = val;
                    }
                });

                scope.$watch(attrs.dragDelay, function (val) {
                    if (typeof val == 'number') {
                        scope.dragDelay = val;
                    }
                });

                /**
                 * Callback checks if the destination node can accept the dragged node.
                 * By default, ui-tree will check that 'data-nodrop-enabled' is not set for the
                 * destination ui-tree-nodes, and that the 'max-depth' attribute will not be exceeded
                 * if it is set on the ui-tree or ui-tree-nodes.
                 * This callback can be overridden, but callers must manually enforce nodrop and max-depth
                 * themselves if they need those to be enforced.
                 * @param sourceNodeScope Scope of the ui-tree-node being dragged
                 * @param destNodesScope Scope of the ui-tree-nodes where the node is hovering
                 * @param destIndex Index in the destination nodes array where the source node will drop
                 * @returns {boolean} True if the node is permitted to be dropped here
                 */
                callbacks.accept = function (sourceNodeScope, destNodesScope, destIndex) {
                    return !(destNodesScope.nodropEnabled || destNodesScope.$treeScope.nodropEnabled || destNodesScope.outOfDepth(sourceNodeScope));
                };

                callbacks.beforeDrag = function (sourceNodeScope) {
                    return true;
                };

                callbacks.removed = function (node) {};

                /**
                 * Callback is fired when a node is successfully dropped in a new location
                 * @param event
                 */
                callbacks.dropped = function (event) {};

                /**
                 * Callback is fired each time the user starts dragging a node
                 * @param event
                 */
                callbacks.dragStart = function (event) {};

                /**
                 * Callback is fired each time a dragged node is moved with the mouse/touch.
                 * @param event
                 */
                callbacks.dragMove = function (event) {};

                /**
                 * Callback is fired when the tree exits drag mode. If the user dropped a node, the drop may have been
                 * accepted or reverted.
                 * @param event
                 */
                callbacks.dragStop = function (event) {};

                /**
                 * Callback is fired when a user drops a node (but prior to processing the drop action)
                 * beforeDrop can return a Promise, truthy, or falsy (returning nothing is falsy).
                 * If it returns falsy, or a resolve Promise, the node move is accepted
                 * If it returns truthy, or a rejected Promise, the node move is reverted
                 * @param event
                 * @returns {Boolean|Promise} Truthy (or rejected Promise) to cancel node move; falsy (or resolved promise)
                 */
                callbacks.beforeDrop = function (event) {};

                scope.$watch(attrs.uiTree, function (newVal, oldVal) {
                    angular.forEach(newVal, function (value, key) {
                        if (callbacks[key]) {
                            if (typeof value === 'function') {
                                callbacks[key] = value;
                            }
                        }
                    });

                    scope.$callbacks = callbacks;
                }, true);
            }
        };
    }]);
})();

(function () {
    'use strict';

    angular.module('ui.tree').directive('uiTreeHandle', ['treeConfig', function (treeConfig) {
        return {
            require: '^uiTreeNode',
            restrict: 'A',
            scope: true,
            controller: 'TreeHandleController',
            link: function link(scope, element, attrs, treeNodeCtrl) {
                var config = {};
                angular.extend(config, treeConfig);
                if (config.handleClass) {
                    element.addClass(config.handleClass);
                }
                // connect with the tree node.
                if (scope != treeNodeCtrl.scope) {
                    scope.$nodeScope = treeNodeCtrl.scope;
                    treeNodeCtrl.scope.$handleScope = scope;
                }
            }
        };
    }]);
})();

(function () {
    'use strict';

    angular.module('ui.tree').directive('uiTreeNode', ['treeConfig', 'UiTreeHelper', '$window', '$document', '$timeout', '$q', '$rootElement', function (treeConfig, UiTreeHelper, $window, $document, $timeout, $q, $rootElement) {
        return {
            require: ['^uiTreeNodes', '^uiTree'],
            restrict: 'A',
            controller: 'TreeNodeController',
            link: function link(scope, element, attrs, controllersArr) {
                // todo startPos is unused
                var config = {},
                    hasTouch = 'ontouchstart' in window,
                    startPos,
                    firstMoving,
                    dragInfo,
                    pos,
                    placeElm,
                    hiddenPlaceElm,
                    dragElm,
                    treeScope = null,
                    elements,
                    // As a parameter for callbacks
                dragDelaying = true,
                    dragStarted = false,
                    dragTimer = null,
                    body = document.body,
                    html = document.documentElement,
                    document_height,
                    document_width,
                    dragStart,
                    tagName,
                    dragMove,
                    dragEnd,
                    dragStartEvent,
                    dragMoveEvent,
                    dragEndEvent,
                    dragCancelEvent,
                    dragDelay,
                    bindDragStartEvents,
                    bindDragMoveEvents,
                    unbindDragMoveEvents,
                    keydownHandler,
                    outOfBounds,
                    isHandleChild,
                    el;

                angular.extend(config, treeConfig);
                if (config.nodeClass) {
                    element.addClass(config.nodeClass);
                }
                scope.init(controllersArr);

                scope.collapsed = !!UiTreeHelper.getNodeAttribute(scope, 'collapsed') || treeConfig.defaultCollapsed;
                scope.sourceOnly = scope.nodropEnabled || scope.$treeScope.nodropEnabled;

                scope.$watch(attrs.collapsed, function (val) {
                    if (typeof val == 'boolean') {
                        scope.collapsed = val;
                    }
                });

                scope.$watch('collapsed', function (val) {
                    UiTreeHelper.setNodeAttribute(scope, 'collapsed', val);
                    attrs.$set('collapsed', val);
                });

                scope.$on('angular-ui-tree:collapse-all', function () {
                    scope.collapsed = true;
                });

                scope.$on('angular-ui-tree:expand-all', function () {
                    scope.collapsed = false;
                });

                /**
                 * Called when the user has grabbed a node and started dragging it
                 * @param e
                 */
                dragStart = function dragStart(e) {
                    // disable right click
                    if (!hasTouch && (e.button === 2 || e.which === 3)) {
                        return;
                    }

                    // event has already fired in other scope
                    if (e.uiTreeDragging || e.originalEvent && e.originalEvent.uiTreeDragging) {
                        return;
                    }

                    // the node being dragged
                    var eventElm = angular.element(e.target),
                        isHandleChild,
                        cloneElm,
                        eventElmTagName,
                        tagName,
                        eventObj,
                        tdElm,
                        hStyle,
                        isTreeNode,
                        isTreeNodeHandle;

                    // if the target element is a child element of a ui-tree-handle,
                    // use the containing handle element as target element
                    isHandleChild = UiTreeHelper.treeNodeHandlerContainerOfElement(eventElm);
                    if (isHandleChild) {
                        eventElm = angular.element(isHandleChild);
                    }

                    cloneElm = element.clone();
                    isTreeNode = UiTreeHelper.elementIsTreeNode(eventElm);
                    isTreeNodeHandle = UiTreeHelper.elementIsTreeNodeHandle(eventElm);

                    if (!isTreeNode && !isTreeNodeHandle) {
                        return;
                    }

                    if (isTreeNode && UiTreeHelper.elementContainsTreeNodeHandler(eventElm)) {
                        return;
                    }

                    eventElmTagName = eventElm.prop('tagName').toLowerCase();
                    if (eventElmTagName == 'input' || eventElmTagName == 'textarea' || eventElmTagName == 'button' || eventElmTagName == 'select') {
                        // if it's a input or button, ignore it
                        return;
                    }

                    // check if it or it's parents has a 'data-nodrag' attribute
                    el = angular.element(e.target);
                    while (el && el[0] && el[0] !== element) {
                        if (UiTreeHelper.nodrag(el)) {
                            // if the node mark as `nodrag`, DONOT drag it.
                            return;
                        }
                        el = el.parent();
                    }

                    if (!scope.beforeDrag(scope)) {
                        return;
                    }

                    e.uiTreeDragging = true; // stop event bubbling
                    if (e.originalEvent) {
                        e.originalEvent.uiTreeDragging = true;
                    }
                    e.preventDefault();
                    eventObj = UiTreeHelper.eventObj(e);

                    firstMoving = true;
                    dragInfo = UiTreeHelper.dragInfo(scope);

                    tagName = element.prop('tagName');

                    if (tagName.toLowerCase() === 'tr') {
                        placeElm = angular.element($window.document.createElement(tagName));
                        tdElm = angular.element($window.document.createElement('td')).addClass(config.placeholderClass).attr('colspan', element[0].children.length);
                        placeElm.append(tdElm);
                    } else {
                        placeElm = angular.element($window.document.createElement(tagName)).addClass(config.placeholderClass);
                    }
                    hiddenPlaceElm = angular.element($window.document.createElement(tagName));
                    if (config.hiddenClass) {
                        hiddenPlaceElm.addClass(config.hiddenClass);
                    }

                    pos = UiTreeHelper.positionStarted(eventObj, element);
                    placeElm.css('height', UiTreeHelper.height(element) + 'px');

                    dragElm = angular.element($window.document.createElement(scope.$parentNodesScope.$element.prop('tagName'))).addClass(scope.$parentNodesScope.$element.attr('class')).addClass(config.dragClass);
                    dragElm.css('width', UiTreeHelper.width(element) + 'px');
                    dragElm.css('z-index', 9999);

                    // Prevents cursor to change rapidly in Opera 12.16 and IE when dragging an element
                    hStyle = (element[0].querySelector('.angular-ui-tree-handle') || element[0]).currentStyle;
                    if (hStyle) {
                        document.body.setAttribute('ui-tree-cursor', $document.find('body').css('cursor') || '');
                        $document.find('body').css({ 'cursor': hStyle.cursor + '!important' });
                    }

                    if (scope.sourceOnly) {
                        placeElm.css('display', 'none');
                    }
                    element.after(placeElm);
                    element.after(hiddenPlaceElm);
                    if (dragInfo.isClone() && scope.sourceOnly) {
                        dragElm.append(cloneElm);
                    } else {
                        dragElm.append(element);
                    }

                    $rootElement.append(dragElm);

                    dragElm.css({
                        'left': eventObj.pageX - pos.offsetX + 'px',
                        'top': eventObj.pageY - pos.offsetY + 'px'
                    });
                    elements = {
                        placeholder: placeElm,
                        dragging: dragElm
                    };

                    bindDragMoveEvents();
                    // Fire dragStart callback
                    scope.$apply(function () {
                        scope.$treeScope.$callbacks.dragStart(dragInfo.eventArgs(elements, pos));
                    });

                    document_height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
                    document_width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);
                };

                dragMove = function dragMove(e) {
                    var eventObj = UiTreeHelper.eventObj(e),
                        prev,
                        next,
                        leftElmPos,
                        topElmPos,
                        top_scroll,
                        bottom_scroll,
                        target,
                        decrease,
                        targetX,
                        targetY,
                        displayElm,
                        targetNode,
                        targetElm,
                        isEmpty,
                        targetOffset,
                        targetBefore;

                    if (dragElm) {
                        e.preventDefault();

                        if ($window.getSelection) {
                            $window.getSelection().removeAllRanges();
                        } else if ($window.document.selection) {
                            $window.document.selection.empty();
                        }

                        leftElmPos = eventObj.pageX - pos.offsetX;
                        topElmPos = eventObj.pageY - pos.offsetY;

                        //dragElm can't leave the screen on the left
                        if (leftElmPos < 0) {
                            leftElmPos = 0;
                        }

                        //dragElm can't leave the screen on the top
                        if (topElmPos < 0) {
                            topElmPos = 0;
                        }

                        //dragElm can't leave the screen on the bottom
                        if (topElmPos + 10 > document_height) {
                            topElmPos = document_height - 10;
                        }

                        //dragElm can't leave the screen on the right
                        if (leftElmPos + 10 > document_width) {
                            leftElmPos = document_width - 10;
                        }

                        dragElm.css({
                            'left': leftElmPos + 'px',
                            'top': topElmPos + 'px'
                        });

                        top_scroll = window.pageYOffset || $window.document.documentElement.scrollTop;
                        bottom_scroll = top_scroll + (window.innerHeight || $window.document.clientHeight || $window.document.clientHeight);

                        // to scroll down if cursor y-position is greater than the bottom position the vertical scroll
                        if (bottom_scroll < eventObj.pageY && bottom_scroll <= document_height) {
                            window.scrollBy(0, 10);
                        }

                        // to scroll top if cursor y-position is less than the top position the vertical scroll
                        if (top_scroll > eventObj.pageY) {
                            window.scrollBy(0, -10);
                        }

                        UiTreeHelper.positionMoved(e, pos, firstMoving);
                        if (firstMoving) {
                            firstMoving = false;
                            return;
                        }

                        // check if add it as a child node first
                        // todo decrease is unused
                        decrease = UiTreeHelper.offset(dragElm).left - UiTreeHelper.offset(placeElm).left >= config.threshold;

                        targetX = eventObj.pageX - ($window.pageXOffset || $window.document.body.scrollLeft || $window.document.documentElement.scrollLeft) - ($window.document.documentElement.clientLeft || 0);

                        targetY = eventObj.pageY - ($window.pageYOffset || $window.document.body.scrollTop || $window.document.documentElement.scrollTop) - ($window.document.documentElement.clientTop || 0);

                        // Select the drag target. Because IE does not support CSS 'pointer-events: none', it will always
                        // pick the drag element itself as the target. To prevent this, we hide the drag element while
                        // selecting the target.
                        if (angular.isFunction(dragElm.hide)) {
                            dragElm.hide();
                        } else {
                            displayElm = dragElm[0].style.display;
                            dragElm[0].style.display = 'none';
                        }

                        // when using elementFromPoint() inside an iframe, you have to call
                        // elementFromPoint() twice to make sure IE8 returns the correct value
                        $window.document.elementFromPoint(targetX, targetY);

                        targetElm = angular.element($window.document.elementFromPoint(targetX, targetY));

                        // if the target element is a child element of a ui-tree-handle,
                        // use the containing handle element as target element
                        isHandleChild = UiTreeHelper.treeNodeHandlerContainerOfElement(targetElm);
                        if (isHandleChild) {
                            targetElm = angular.element(isHandleChild);
                        }

                        if (angular.isFunction(dragElm.show)) {
                            dragElm.show();
                        } else {
                            dragElm[0].style.display = displayElm;
                        }

                        outOfBounds = !UiTreeHelper.elementIsTreeNodeHandle(targetElm) && !UiTreeHelper.elementIsTreeNode(targetElm) && !UiTreeHelper.elementIsTreeNodes(targetElm) && !UiTreeHelper.elementIsTree(targetElm) && !UiTreeHelper.elementIsPlaceholder(targetElm);

                        // Detect out of bounds condition, update drop target display, and prevent drop
                        if (outOfBounds) {

                            // Remove the placeholder
                            placeElm.remove();

                            // If the target was an empty tree, replace the empty element placeholder
                            if (treeScope) {
                                treeScope.resetEmptyElement();
                                treeScope = null;
                            }
                        }

                        // move horizontal
                        if (pos.dirAx && pos.distAxX >= config.levelThreshold) {
                            pos.distAxX = 0;

                            // increase horizontal level if previous sibling exists and is not collapsed
                            if (pos.distX > 0) {
                                prev = dragInfo.prev();
                                if (prev && !prev.collapsed && prev.accept(scope, prev.childNodesCount())) {
                                    prev.$childNodesScope.$element.append(placeElm);
                                    dragInfo.moveTo(prev.$childNodesScope, prev.childNodes(), prev.childNodesCount());
                                }
                            }

                            // decrease horizontal level
                            if (pos.distX < 0) {
                                // we can't decrease a level if an item preceeds the current one
                                next = dragInfo.next();
                                if (!next) {
                                    target = dragInfo.parentNode(); // As a sibling of it's parent node
                                    if (target && target.$parentNodesScope.accept(scope, target.index() + 1)) {
                                        target.$element.after(placeElm);
                                        dragInfo.moveTo(target.$parentNodesScope, target.siblings(), target.index() + 1);
                                    }
                                }
                            }
                        }

                        // move vertical
                        if (!pos.dirAx) {
                            if (UiTreeHelper.elementIsTree(targetElm)) {
                                targetNode = targetElm.controller('uiTree').scope;
                            } else if (UiTreeHelper.elementIsTreeNodeHandle(targetElm)) {
                                targetNode = targetElm.controller('uiTreeHandle').scope;
                            } else if (UiTreeHelper.elementIsTreeNode(targetElm)) {
                                targetNode = targetElm.controller('uiTreeNode').scope;
                            } else if (UiTreeHelper.elementIsTreeNodes(targetElm)) {
                                targetNode = targetElm.controller('uiTreeNodes').scope;
                            } else if (UiTreeHelper.elementIsPlaceholder(targetElm)) {
                                targetNode = targetElm.controller('uiTreeNodes').scope;
                            } else if (targetElm.controller('uiTreeNode')) {
                                // is a child element of a node
                                targetNode = targetElm.controller('uiTreeNode').scope;
                            }

                            // check it's new position
                            isEmpty = false;
                            if (!targetNode) {
                                return;
                            }

                            // Show the placeholder if it was hidden for nodrop-enabled and this is a new tree
                            if (targetNode.$treeScope && !targetNode.$parent.nodropEnabled && !targetNode.$treeScope.nodropEnabled) {
                                placeElm.css('display', '');
                            }

                            if (targetNode.$type == 'uiTree' && targetNode.dragEnabled) {
                                isEmpty = targetNode.isEmpty(); // Check if it's empty tree
                            }

                            if (targetNode.$type == 'uiTreeHandle') {
                                targetNode = targetNode.$nodeScope;
                            }

                            if (targetNode.$type != 'uiTreeNode' && !isEmpty) {
                                // Check if it is a uiTreeNode or it's an empty tree
                                return;
                            }

                            // if placeholder move from empty tree, reset it.
                            if (treeScope && placeElm.parent()[0] != treeScope.$element[0]) {
                                treeScope.resetEmptyElement();
                                treeScope = null;
                            }

                            if (isEmpty) {
                                // it's an empty tree
                                treeScope = targetNode;
                                if (targetNode.$nodesScope.accept(scope, 0)) {
                                    targetNode.place(placeElm);
                                    dragInfo.moveTo(targetNode.$nodesScope, targetNode.$nodesScope.childNodes(), 0);
                                }
                            } else if (targetNode.dragEnabled()) {
                                // drag enabled
                                targetElm = targetNode.$element; // Get the element of ui-tree-node
                                targetOffset = UiTreeHelper.offset(targetElm);
                                targetBefore = targetNode.horizontal ? eventObj.pageX < targetOffset.left + UiTreeHelper.width(targetElm) / 2 : eventObj.pageY < targetOffset.top + UiTreeHelper.height(targetElm) / 2;

                                if (targetNode.$parentNodesScope.accept(scope, targetNode.index())) {
                                    if (targetBefore) {
                                        targetElm[0].parentNode.insertBefore(placeElm[0], targetElm[0]);
                                        dragInfo.moveTo(targetNode.$parentNodesScope, targetNode.siblings(), targetNode.index());
                                    } else {
                                        targetElm.after(placeElm);
                                        dragInfo.moveTo(targetNode.$parentNodesScope, targetNode.siblings(), targetNode.index() + 1);
                                    }
                                } else if (!targetBefore && targetNode.accept(scope, targetNode.childNodesCount())) {
                                    // we have to check if it can add the dragging node as a child
                                    targetNode.$childNodesScope.$element.append(placeElm);
                                    dragInfo.moveTo(targetNode.$childNodesScope, targetNode.childNodes(), targetNode.childNodesCount());
                                } else {
                                    outOfBounds = true;
                                }
                            }
                        }

                        scope.$apply(function () {
                            scope.$treeScope.$callbacks.dragMove(dragInfo.eventArgs(elements, pos));
                        });
                    }
                };

                dragEnd = function dragEnd(e) {
                    var dragEventArgs = dragInfo.eventArgs(elements, pos);
                    e.preventDefault();
                    unbindDragMoveEvents();

                    scope.$treeScope.$apply(function () {
                        $q.when(scope.$treeScope.$callbacks.beforeDrop(dragEventArgs))
                        // promise resolved (or callback didn't return false)
                        .then(function (allowDrop) {
                            if (allowDrop !== false && scope.$$allowNodeDrop && !outOfBounds) {
                                // node drop accepted)
                                dragInfo.apply();
                                // fire the dropped callback only if the move was successful
                                scope.$treeScope.$callbacks.dropped(dragEventArgs);
                            } else {
                                // drop canceled - revert the node to its original position
                                bindDragStartEvents();
                            }
                        })
                        // promise rejected - revert the node to its original position
                        .catch(function () {
                            bindDragStartEvents();
                        }).finally(function () {
                            hiddenPlaceElm.replaceWith(scope.$element);
                            placeElm.remove();

                            if (dragElm) {
                                // drag element is attached to the mouse pointer
                                dragElm.remove();
                                dragElm = null;
                            }
                            scope.$treeScope.$callbacks.dragStop(dragEventArgs);
                            scope.$$allowNodeDrop = false;
                            dragInfo = null;

                            // Restore cursor in Opera 12.16 and IE
                            var oldCur = document.body.getAttribute('ui-tree-cursor');
                            if (oldCur !== null) {
                                $document.find('body').css({ 'cursor': oldCur });
                                document.body.removeAttribute('ui-tree-cursor');
                            }
                        });
                    });
                };

                dragStartEvent = function dragStartEvent(e) {
                    if (scope.dragEnabled()) {
                        dragStart(e);
                    }
                };

                dragMoveEvent = function dragMoveEvent(e) {
                    dragMove(e);
                };

                dragEndEvent = function dragEndEvent(e) {
                    scope.$$allowNodeDrop = true;
                    dragEnd(e);
                };

                dragCancelEvent = function dragCancelEvent(e) {
                    dragEnd(e);
                };

                dragDelay = function () {
                    var to;

                    return {
                        exec: function exec(fn, ms) {
                            if (!ms) {
                                ms = 0;
                            }
                            this.cancel();
                            to = $timeout(fn, ms);
                        },
                        cancel: function cancel() {
                            $timeout.cancel(to);
                        }
                    };
                }();

                /**
                 * Binds the mouse/touch events to enable drag start for this node
                 */
                bindDragStartEvents = function bindDragStartEvents() {
                    element.bind('touchstart mousedown', function (e) {
                        dragDelay.exec(function () {
                            dragStartEvent(e);
                        }, scope.dragDelay || 0);
                    });
                    element.bind('touchend touchcancel mouseup', function () {
                        dragDelay.cancel();
                    });
                };
                bindDragStartEvents();

                /**
                 * Binds mouse/touch events that handle moving/dropping this dragged node
                 */
                bindDragMoveEvents = function bindDragMoveEvents() {
                    angular.element($document).bind('touchend', dragEndEvent);
                    angular.element($document).bind('touchcancel', dragEndEvent);
                    angular.element($document).bind('touchmove', dragMoveEvent);
                    angular.element($document).bind('mouseup', dragEndEvent);
                    angular.element($document).bind('mousemove', dragMoveEvent);
                    angular.element($document).bind('mouseleave', dragCancelEvent);
                };

                /**
                 * Unbinds mouse/touch events that handle moving/dropping this dragged node
                 */
                unbindDragMoveEvents = function unbindDragMoveEvents() {
                    angular.element($document).unbind('touchend', dragEndEvent);
                    angular.element($document).unbind('touchcancel', dragEndEvent);
                    angular.element($document).unbind('touchmove', dragMoveEvent);
                    angular.element($document).unbind('mouseup', dragEndEvent);
                    angular.element($document).unbind('mousemove', dragMoveEvent);
                    angular.element($document).unbind('mouseleave', dragCancelEvent);
                };

                keydownHandler = function keydownHandler(e) {
                    if (e.keyCode == 27) {
                        scope.$$allowNodeDrop = false;
                        dragEnd(e);
                    }
                };

                angular.element($window.document).bind('keydown', keydownHandler);

                //unbind handler that retains scope
                scope.$on('$destroy', function () {
                    angular.element($window.document).unbind('keydown', keydownHandler);
                });
            }
        };
    }]);
})();

(function () {
    'use strict';

    angular.module('ui.tree').directive('uiTreeNodes', ['treeConfig', '$window', function (treeConfig) {
        return {
            require: ['ngModel', '?^uiTreeNode', '^uiTree'],
            restrict: 'A',
            scope: true,
            controller: 'TreeNodesController',
            link: function link(scope, element, attrs, controllersArr) {

                var config = {},
                    ngModel = controllersArr[0],
                    treeNodeCtrl = controllersArr[1],
                    treeCtrl = controllersArr[2];

                angular.extend(config, treeConfig);
                if (config.nodesClass) {
                    element.addClass(config.nodesClass);
                }

                if (treeNodeCtrl) {
                    treeNodeCtrl.scope.$childNodesScope = scope;
                    scope.$nodeScope = treeNodeCtrl.scope;
                } else {
                    // find the root nodes if there is no parent node and have a parent ui-tree
                    treeCtrl.scope.$nodesScope = scope;
                }
                scope.$treeScope = treeCtrl.scope;

                if (ngModel) {
                    ngModel.$render = function () {
                        scope.$modelValue = ngModel.$modelValue;
                    };
                }

                scope.$watch(function () {
                    return attrs.maxDepth;
                }, function (val) {
                    if (typeof val == 'number') {
                        scope.maxDepth = val;
                    }
                });

                scope.$watch(function () {
                    return attrs.nodropEnabled;
                }, function (newVal) {
                    if (typeof newVal != 'undefined') {
                        scope.nodropEnabled = true;
                    }
                }, true);

                attrs.$observe('horizontal', function (val) {
                    scope.horizontal = typeof val != 'undefined';
                });
            }
        };
    }]);
})();

(function () {
    'use strict';

    angular.module('ui.tree')

    /**
     * @ngdoc service
     * @name ui.tree.service:UiTreeHelper
     * @requires ng.$document
     * @requires ng.$window
     *
     * @description
     * angular-ui-tree.
     */
    .factory('UiTreeHelper', ['$document', '$window', 'treeConfig', function ($document, $window, treeConfig) {
        return {

            /**
             * A hashtable used to storage data of nodes
             * @type {Object}
             */
            nodesData: {},

            setNodeAttribute: function setNodeAttribute(scope, attrName, val) {
                if (!scope.$modelValue) {
                    return null;
                }
                var data = this.nodesData[scope.$modelValue.$$hashKey];
                if (!data) {
                    data = {};
                    this.nodesData[scope.$modelValue.$$hashKey] = data;
                }
                data[attrName] = val;
            },

            getNodeAttribute: function getNodeAttribute(scope, attrName) {
                if (!scope.$modelValue) {
                    return null;
                }
                var data = this.nodesData[scope.$modelValue.$$hashKey];
                if (data) {
                    return data[attrName];
                }
                return null;
            },

            /**
             * @ngdoc method
             * @methodOf ui.tree.service:$nodrag
             * @param  {Object} targetElm angular element
             * @return {Bool} check if the node can be dragged.
             */
            nodrag: function nodrag(targetElm) {
                if (typeof targetElm.attr('data-nodrag') != 'undefined') {
                    return targetElm.attr('data-nodrag') !== 'false';
                }
                return false;
            },

            /**
             * get the event object for touches
             * @param  {[type]} e [description]
             * @return {[type]}   [description]
             */
            eventObj: function eventObj(e) {
                var obj = e;
                if (e.targetTouches !== undefined) {
                    obj = e.targetTouches.item(0);
                } else if (e.originalEvent !== undefined && e.originalEvent.targetTouches !== undefined) {
                    obj = e.originalEvent.targetTouches.item(0);
                }
                return obj;
            },

            dragInfo: function dragInfo(node) {
                return {
                    source: node,
                    sourceInfo: {
                        cloneModel: node.$treeScope.cloneEnabled === true ? angular.copy(node.$modelValue) : undefined,
                        nodeScope: node,
                        index: node.index(),
                        nodesScope: node.$parentNodesScope
                    },
                    index: node.index(),
                    siblings: node.siblings().slice(0),
                    parent: node.$parentNodesScope,

                    // Move the node to a new position
                    moveTo: function moveTo(parent, siblings, index) {
                        this.parent = parent;
                        this.siblings = siblings.slice(0);

                        // If source node is in the target nodes
                        var i = this.siblings.indexOf(this.source);
                        if (i > -1) {
                            this.siblings.splice(i, 1);
                            if (this.source.index() < index) {
                                index--;
                            }
                        }

                        this.siblings.splice(index, 0, this.source);
                        this.index = index;
                    },

                    parentNode: function parentNode() {
                        return this.parent.$nodeScope;
                    },

                    prev: function prev() {
                        if (this.index > 0) {
                            return this.siblings[this.index - 1];
                        }

                        return null;
                    },

                    next: function next() {
                        if (this.index < this.siblings.length - 1) {
                            return this.siblings[this.index + 1];
                        }

                        return null;
                    },

                    isClone: function isClone() {
                        return this.source.$treeScope.cloneEnabled === true;
                    },

                    clonedNode: function clonedNode(node) {
                        return angular.copy(node);
                    },

                    isDirty: function isDirty() {
                        return this.source.$parentNodesScope != this.parent || this.source.index() != this.index;
                    },

                    isForeign: function isForeign() {
                        return this.source.$treeScope !== this.parent.$treeScope;
                    },

                    eventArgs: function eventArgs(elements, pos) {
                        return {
                            source: this.sourceInfo,
                            dest: {
                                index: this.index,
                                nodesScope: this.parent
                            },
                            elements: elements,
                            pos: pos
                        };
                    },

                    apply: function apply() {

                        var nodeData = this.source.$modelValue;

                        // nodrop enabled on tree or parent
                        if (this.parent.nodropEnabled || this.parent.$treeScope.nodropEnabled) {
                            return;
                        }

                        // node was dropped in the same place - do nothing
                        if (!this.isDirty()) {
                            return;
                        }

                        // cloneEnabled and cross-tree so copy and do not remove from source
                        if (this.isClone() && this.isForeign()) {
                            this.parent.insertNode(this.index, this.sourceInfo.cloneModel);
                        } else {
                            // Any other case, remove and reinsert
                            this.source.remove();
                            this.parent.insertNode(this.index, nodeData);
                        }
                    }
                };
            },

            /**
             * @ngdoc method
             * @name ui.tree#height
             * @methodOf ui.tree.service:UiTreeHelper
             *
             * @description
             * Get the height of an element.
             *
             * @param {Object} element Angular element.
             * @returns {String} Height
             */
            height: function height(element) {
                return element.prop('scrollHeight');
            },

            /**
             * @ngdoc method
             * @name ui.tree#width
             * @methodOf ui.tree.service:UiTreeHelper
             *
             * @description
             * Get the width of an element.
             *
             * @param {Object} element Angular element.
             * @returns {String} Width
             */
            width: function width(element) {
                return element.prop('scrollWidth');
            },

            /**
             * @ngdoc method
             * @name ui.tree#offset
             * @methodOf ui.nestedSortable.service:UiTreeHelper
             *
             * @description
             * Get the offset values of an element.
             *
             * @param {Object} element Angular element.
             * @returns {Object} Object with properties width, height, top and left
             */
            offset: function offset(element) {
                var boundingClientRect = element[0].getBoundingClientRect();

                return {
                    width: element.prop('offsetWidth'),
                    height: element.prop('offsetHeight'),
                    top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop || $document[0].documentElement.scrollTop),
                    left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft || $document[0].documentElement.scrollLeft)
                };
            },

            /**
             * @ngdoc method
             * @name ui.tree#positionStarted
             * @methodOf ui.tree.service:UiTreeHelper
             *
             * @description
             * Get the start position of the target element according to the provided event properties.
             *
             * @param {Object} e Event
             * @param {Object} target Target element
             * @returns {Object} Object with properties offsetX, offsetY, startX, startY, nowX and dirX.
             */
            positionStarted: function positionStarted(e, target) {
                var pos = {},
                    pageX = e.pageX,
                    pageY = e.pageY;

                if (e.originalEvent && e.originalEvent.touches && e.originalEvent.touches.length > 0) {
                    pageX = e.originalEvent.touches[0].pageX;
                    pageY = e.originalEvent.touches[0].pageY;
                }
                pos.offsetX = pageX - this.offset(target).left;
                pos.offsetY = pageY - this.offset(target).top;
                pos.startX = pos.lastX = pageX;
                pos.startY = pos.lastY = pageY;
                pos.nowX = pos.nowY = pos.distX = pos.distY = pos.dirAx = 0;
                pos.dirX = pos.dirY = pos.lastDirX = pos.lastDirY = pos.distAxX = pos.distAxY = 0;
                return pos;
            },

            positionMoved: function positionMoved(e, pos, firstMoving) {
                var pageX = e.pageX,
                    pageY = e.pageY,
                    newAx;
                if (e.originalEvent && e.originalEvent.touches && e.originalEvent.touches.length > 0) {
                    pageX = e.originalEvent.touches[0].pageX;
                    pageY = e.originalEvent.touches[0].pageY;
                }
                // mouse position last events
                pos.lastX = pos.nowX;
                pos.lastY = pos.nowY;

                // mouse position this events
                pos.nowX = pageX;
                pos.nowY = pageY;

                // distance mouse moved between events
                pos.distX = pos.nowX - pos.lastX;
                pos.distY = pos.nowY - pos.lastY;

                // direction mouse was moving
                pos.lastDirX = pos.dirX;
                pos.lastDirY = pos.dirY;

                // direction mouse is now moving (on both axis)
                pos.dirX = pos.distX === 0 ? 0 : pos.distX > 0 ? 1 : -1;
                pos.dirY = pos.distY === 0 ? 0 : pos.distY > 0 ? 1 : -1;

                // axis mouse is now moving on
                newAx = Math.abs(pos.distX) > Math.abs(pos.distY) ? 1 : 0;

                // do nothing on first move
                if (firstMoving) {
                    pos.dirAx = newAx;
                    pos.moving = true;
                    return;
                }

                // calc distance moved on this axis (and direction)
                if (pos.dirAx !== newAx) {
                    pos.distAxX = 0;
                    pos.distAxY = 0;
                } else {
                    pos.distAxX += Math.abs(pos.distX);
                    if (pos.dirX !== 0 && pos.dirX !== pos.lastDirX) {
                        pos.distAxX = 0;
                    }

                    pos.distAxY += Math.abs(pos.distY);
                    if (pos.dirY !== 0 && pos.dirY !== pos.lastDirY) {
                        pos.distAxY = 0;
                    }
                }

                pos.dirAx = newAx;
            },

            elementIsTreeNode: function elementIsTreeNode(element) {
                return typeof element.attr('ui-tree-node') !== 'undefined';
            },

            elementIsTreeNodeHandle: function elementIsTreeNodeHandle(element) {
                return typeof element.attr('ui-tree-handle') !== 'undefined';
            },
            elementIsTree: function elementIsTree(element) {
                return typeof element.attr('ui-tree') !== 'undefined';
            },
            elementIsTreeNodes: function elementIsTreeNodes(element) {
                return typeof element.attr('ui-tree-nodes') !== 'undefined';
            },
            elementIsPlaceholder: function elementIsPlaceholder(element) {
                return element.hasClass(treeConfig.placeholderClass);
            },
            elementContainsTreeNodeHandler: function elementContainsTreeNodeHandler(element) {
                return element[0].querySelectorAll('[ui-tree-handle]').length >= 1;
            },
            treeNodeHandlerContainerOfElement: function treeNodeHandlerContainerOfElement(element) {
                return findFirstParentElementWithAttribute('ui-tree-handle', element[0]);
            }
        };
    }]);

    // TODO: optimize this loop
    function findFirstParentElementWithAttribute(attributeName, childObj) {
        // undefined if the mouse leaves the browser window
        if (childObj === undefined) {
            return null;
        }
        var testObj = childObj.parentNode,
            count = 1,

        // check for setAttribute due to exception thrown by Firefox when a node is dragged outside the browser window
        res = typeof testObj.setAttribute === 'function' && testObj.hasAttribute(attributeName) ? testObj : null;
        while (testObj && typeof testObj.setAttribute === 'function' && !testObj.hasAttribute(attributeName)) {
            testObj = testObj.parentNode;
            res = testObj;
            if (testObj === document.documentElement) {
                res = null;
                break;
            }
            count++;
        }

        return res;
    }
})();